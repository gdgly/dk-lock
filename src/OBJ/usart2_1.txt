; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\usart2_1.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\usart2_1.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\FLib\inc -I..\CORE -I..\driver -I..\BSP -I..\SYS -I..\tplib -IE:\github\dk-lock\src\Proj\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=..\obj\usart2_1.crf ..\driver\usart2.c]
                          THUMB

                          AREA ||i.TIM3_Init||, CODE, READONLY, ALIGN=2

                  TIM3_Init PROC
;;;230    //psc：时钟预分频数		 
;;;231    void TIM3_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;232    {	
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;233    	NVIC_InitTypeDef NVIC_InitStructure;
;;;234    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;235    
;;;236    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能//TIM4时钟使能    
000006  2101              MOVS     r1,#1
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;237    	
;;;238    	//定时器TIM3初始化
;;;239    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	
00000e  f8ad5004          STRH     r5,[sp,#4]
;;;240    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值
000012  f8ad4000          STRH     r4,[sp,#0]
;;;241    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
000016  2000              MOVS     r0,#0
000018  f8ad0006          STRH     r0,[sp,#6]
;;;242    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
00001c  f8ad0002          STRH     r0,[sp,#2]
;;;243    	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx的时间基数单位
000020  4669              MOV      r1,sp
000022  480c              LDR      r0,|L1.84|
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;244     
;;;245    	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //使能指定的TIM4中断,允许更新中断
000028  2201              MOVS     r2,#1
00002a  4611              MOV      r1,r2
00002c  4809              LDR      r0,|L1.84|
00002e  f7fffffe          BL       TIM_ITConfig
;;;246    
;;;247    	 	  
;;;248    	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
000032  201d              MOVS     r0,#0x1d
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;249    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;//抢占优先级3
000038  2001              MOVS     r0,#1
00003a  f88d000d          STRB     r0,[sp,#0xd]
;;;250    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;		//子优先级3
00003e  2002              MOVS     r0,#2
000040  f88d000e          STRB     r0,[sp,#0xe]
;;;251    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000044  2001              MOVS     r0,#1
000046  f88d000f          STRB     r0,[sp,#0xf]
;;;252    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00004a  a803              ADD      r0,sp,#0xc
00004c  f7fffffe          BL       NVIC_Init
;;;253    	
;;;254    }
000050  bd7f              POP      {r0-r6,pc}
;;;255    
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      0x40000400

                          AREA ||i.TIM3_Set||, CODE, READONLY, ALIGN=2

                  TIM3_Set PROC
;;;217    //sta:0，关闭;1,开启;
;;;218    void TIM3_Set(u8 sta)
000000  b510              PUSH     {r4,lr}
;;;219    {
000002  4604              MOV      r4,r0
;;;220    	if(sta)
000004  b144              CBZ      r4,|L2.24|
;;;221    	{
;;;222           
;;;223    		TIM_SetCounter(TIM3,0);//计数器清空
000006  2100              MOVS     r1,#0
000008  4806              LDR      r0,|L2.36|
00000a  f7fffffe          BL       TIM_SetCounter
;;;224    		TIM_Cmd(TIM3, ENABLE);  //使能TIMx	
00000e  2101              MOVS     r1,#1
000010  4804              LDR      r0,|L2.36|
000012  f7fffffe          BL       TIM_Cmd
000016  e003              B        |L2.32|
                  |L2.24|
;;;225    	}else TIM_Cmd(TIM3, DISABLE);//关闭定时器4	   
000018  2100              MOVS     r1,#0
00001a  4802              LDR      r0,|L2.36|
00001c  f7fffffe          BL       TIM_Cmd
                  |L2.32|
;;;226    }
000020  bd10              POP      {r4,pc}
;;;227    //通用定时器中断初始化
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x40000400

                          AREA ||i.USART12_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART12_IRQHandler PROC
;;;155      */
;;;156    void USART12_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158        unsigned int data;
;;;159    #if 1
;;;160    	/*
;;;161        if(USART2->SR & 0x0F)
;;;162        {
;;;163            // See if we have some kind of error
;;;164            // Clear interrupt (do nothing about it!)
;;;165           // data = USART2->DR;
;;;166    			USART2->SR=0x00c0;		
;;;167        }
;;;168    //    if(USART2->SR & USART_FLAG_RXNE)   //Receive Data Reg Full Flag
;;;169    //    {
;;;170            
;;;171            data = USART2->DR;
;;;172           usart2_rcv_buf[usart2_rcv_len++] = data;
;;;173    			
;;;174    		USART2->SR=0x00c0;
;;;175    
;;;176    		if(usart2_rcv_len >= (MAX_RCV_LEN - 1))
;;;177    			  usart2_rcv_len = 0;
;;;178    //        //usart1_rcv_buf[usart1_rcv_len++]=data;
;;;179    //        //usart1_putrxchar(data);       //Insert received character into buffer
;;;180    //    }
;;;181    
;;;182    //    else
;;;183    //    {
;;;184    //        USART2->SR=0x00c0;
;;;185    //			  USART1->DR='2';
;;;186    //    }
;;;187    	*/
;;;188    	
;;;189    //	 if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)//接收到数据  //Receive Data Reg Full Flag
;;;190    //    {
;;;191    			data=USART_ReceiveData(USART2);
000002  4808              LDR      r0,|L3.36|
000004  f7fffffe          BL       USART_ReceiveData
000008  4604              MOV      r4,r0
;;;192    //			usart2_rcv_buf[usart2_rcv_len++]=data;
;;;193    //		  if(usart2_rcv_len >= (MAX_RCV_LEN - 1))
;;;194    //			  usart2_rcv_len = 0;
;;;195    			
;;;196    			
;;;197    			if(usart2_rcv_len<MAX_RCV_LEN)
00000a  4807              LDR      r0,|L3.40|
00000c  6800              LDR      r0,[r0,#0]  ; usart2_rcv_len
00000e  f5b06f80          CMP      r0,#0x400
000012  d206              BCS      |L3.34|
;;;198    			{
;;;199    			usart2_rcv_buf[usart2_rcv_len++]=data;
000014  4904              LDR      r1,|L3.40|
000016  6808              LDR      r0,[r1,#0]  ; usart2_rcv_len
000018  1c41              ADDS     r1,r0,#1
00001a  4b03              LDR      r3,|L3.40|
00001c  6019              STR      r1,[r3,#0]  ; usart2_rcv_len
00001e  4903              LDR      r1,|L3.44|
000020  540c              STRB     r4,[r1,r0]
                  |L3.34|
;;;200    				//USART1->DR=usart2_rcv_buf[usart2_rcv_len++];
;;;201    //		  if(usart2_rcv_len >= (MAX_RCV_LEN - 1))
;;;202    //			  usart2_rcv_len = 0;
;;;203    //				TIM_SetCounter(TIM3,0);
;;;204    //				if(usart2_rcv_len==0)TIM3_Set(1);
;;;205    //				usart2_rcv_buf[usart2_rcv_len++]=data;
;;;206    			}
;;;207    //			else
;;;208    //			{
;;;209    //				usart2_rcv_len=0;
;;;210    //			}
;;;211    		//}
;;;212    #endif
;;;213    }
000022  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  |L3.36|
                          DCD      0x40004400
                  |L3.40|
                          DCD      usart2_rcv_len
                  |L3.44|
                          DCD      usart2_rcv_buf

                          AREA ||i.USART2_GetRcvData||, CODE, READONLY, ALIGN=2

                  USART2_GetRcvData PROC
;;;139    
;;;140    void  USART2_GetRcvData(uint8_t *buf, uint32_t rcv_len)
000000  b570              PUSH     {r4-r6,lr}
;;;141    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;142        if(buf)
000006  b125              CBZ      r5,|L4.18|
;;;143        {
;;;144            memcpy(buf, usart2_rcv_buf, rcv_len);
000008  4622              MOV      r2,r4
00000a  4902              LDR      r1,|L4.20|
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       __aeabi_memcpy
                  |L4.18|
;;;145        }
;;;146        //USART2_Clear();
;;;147    }
000012  bd70              POP      {r4-r6,pc}
;;;148    #endif
                          ENDP

                  |L4.20|
                          DCD      usart2_rcv_buf

                          AREA ||i.USART2_GetRcvNum||, CODE, READONLY, ALIGN=2

                  USART2_GetRcvNum PROC
;;;119     */
;;;120    uint32_t USART2_GetRcvNum(void)
000000  2000              MOVS     r0,#0
;;;121    {
;;;122    	static uint32_t len = 0;
;;;123    	uint32_t result = 0;
;;;124    	
;;;125    	if(usart2_rcv_len == 0)
000002  490b              LDR      r1,|L5.48|
000004  6809              LDR      r1,[r1,#0]  ; usart2_rcv_len
000006  b919              CBNZ     r1,|L5.16|
;;;126    	{
;;;127    		len = 0;
000008  2100              MOVS     r1,#0
00000a  4a0a              LDR      r2,|L5.52|
00000c  6011              STR      r1,[r2,#0]  ; len
;;;128    		result = 0;
00000e  e00e              B        |L5.46|
                  |L5.16|
;;;129    	}
;;;130    	else if(len != usart2_rcv_len)
000010  4908              LDR      r1,|L5.52|
000012  6809              LDR      r1,[r1,#0]  ; len
000014  4a06              LDR      r2,|L5.48|
000016  6812              LDR      r2,[r2,#0]  ; usart2_rcv_len
000018  4291              CMP      r1,r2
00001a  d008              BEQ      |L5.46|
;;;131    	{
;;;132    		result = usart2_rcv_len - len;	//?????
00001c  4904              LDR      r1,|L5.48|
00001e  6809              LDR      r1,[r1,#0]  ; usart2_rcv_len
000020  4a04              LDR      r2,|L5.52|
000022  6812              LDR      r2,[r2,#0]  ; len
000024  1a88              SUBS     r0,r1,r2
;;;133    		len = usart2_rcv_len;			//?????
000026  4902              LDR      r1,|L5.48|
000028  6809              LDR      r1,[r1,#0]  ; usart2_rcv_len
00002a  4a02              LDR      r2,|L5.52|
00002c  6011              STR      r1,[r2,#0]  ; len
                  |L5.46|
;;;134    	}
;;;135    	
;;;136        return result;
;;;137    }
00002e  4770              BX       lr
;;;138    
                          ENDP

                  |L5.48|
                          DCD      usart2_rcv_len
                  |L5.52|
                          DCD      len

                          AREA ||i.USART2_init||, CODE, READONLY, ALIGN=2

                  USART2_init PROC
;;;22     
;;;23     void USART2_init(u32 bound)
000000  b510              PUSH     {r4,lr}
;;;24     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;25         GPIO_InitTypeDef GPIO_InitStructure;
;;;26         USART_InitTypeDef USART_InitStructure;
;;;27         NVIC_InitTypeDef NVIC_InitStructure;
;;;28     
;;;29         /* config USART2 clock */
;;;30         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;31         RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0448              LSLS     r0,r1,#17
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;32     
;;;33         /* USART2 GPIO config */
;;;34     	/* Set PA2 PA3 as UART1 */
;;;35         /* Configure USART2 Tx (PA.02) as alternate function push-pull */
;;;36         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000016  2004              MOVS     r0,#4
000018  f8ad0014          STRH     r0,[sp,#0x14]
;;;37         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0017          STRB     r0,[sp,#0x17]
;;;38         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0016          STRB     r0,[sp,#0x16]
;;;39         GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a905              ADD      r1,sp,#0x14
00002a  4822              LDR      r0,|L6.180|
00002c  f7fffffe          BL       GPIO_Init
;;;40         /* Configure USART2 Rx (PA.03) as input floating */
;;;41         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
000030  2008              MOVS     r0,#8
000032  f8ad0014          STRH     r0,[sp,#0x14]
;;;42         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000036  2004              MOVS     r0,#4
000038  f88d0017          STRB     r0,[sp,#0x17]
;;;43         GPIO_Init(GPIOA, &GPIO_InitStructure);
00003c  a905              ADD      r1,sp,#0x14
00003e  481d              LDR      r0,|L6.180|
000040  f7fffffe          BL       GPIO_Init
;;;44     
;;;45         /* USART2 mode config */
;;;46         USART_InitStructure.USART_BaudRate = bound;
000044  9401              STR      r4,[sp,#4]
;;;47         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000046  2000              MOVS     r0,#0
000048  f8ad0008          STRH     r0,[sp,#8]
;;;48         USART_InitStructure.USART_StopBits = USART_StopBits_1;
00004c  f8ad000a          STRH     r0,[sp,#0xa]
;;;49         USART_InitStructure.USART_Parity = USART_Parity_No ;
000050  f8ad000c          STRH     r0,[sp,#0xc]
;;;50         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000054  f8ad0010          STRH     r0,[sp,#0x10]
;;;51         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000058  200c              MOVS     r0,#0xc
00005a  f8ad000e          STRH     r0,[sp,#0xe]
;;;52         USART_Init(USART2, &USART_InitStructure);
00005e  a901              ADD      r1,sp,#4
000060  4815              LDR      r0,|L6.184|
000062  f7fffffe          BL       USART_Init
;;;53         USART_Cmd(USART2, ENABLE);
000066  2101              MOVS     r1,#1
000068  4813              LDR      r0,|L6.184|
00006a  f7fffffe          BL       USART_Cmd
;;;54     
;;;55         //Enable usart2 receive interrupt
;;;56         USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
00006e  2201              MOVS     r2,#1
000070  f2405125          MOV      r1,#0x525
000074  4810              LDR      r0,|L6.184|
000076  f7fffffe          BL       USART_ITConfig
;;;57     
;;;58         NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
00007a  2026              MOVS     r0,#0x26
00007c  f88d0000          STRB     r0,[sp,#0]
;;;59         NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000080  2003              MOVS     r0,#3
000082  f88d0001          STRB     r0,[sp,#1]
;;;60         NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
000086  2002              MOVS     r0,#2
000088  f88d0002          STRB     r0,[sp,#2]
;;;61         NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00008c  2001              MOVS     r0,#1
00008e  f88d0003          STRB     r0,[sp,#3]
;;;62         NVIC_Init(&NVIC_InitStructure);
000092  4668              MOV      r0,sp
000094  f7fffffe          BL       NVIC_Init
;;;63     	  TIM3_Init(999,7199);		//10ms中断
000098  f641411f          MOV      r1,#0x1c1f
00009c  f24030e7          MOV      r0,#0x3e7
0000a0  f7fffffe          BL       TIM3_Init
;;;64     	  usart2_rcv_len=0;		//清零
0000a4  2000              MOVS     r0,#0
0000a6  4905              LDR      r1,|L6.188|
0000a8  6008              STR      r0,[r1,#0]  ; usart2_rcv_len
;;;65     	  TIM3_Set(0);			//关闭定时器4
0000aa  f7fffffe          BL       TIM3_Set
;;;66     }
0000ae  b006              ADD      sp,sp,#0x18
0000b0  bd10              POP      {r4,pc}
;;;67     
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
                          DCD      0x40010800
                  |L6.184|
                          DCD      0x40004400
                  |L6.188|
                          DCD      usart2_rcv_len

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  usart2_rcv_buf
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  USART2_RX_STA
000000  0000              DCW      0x0000
                  gprs_ready_flag
000002  00                DCB      0x00
                  gprs_ready_count
000003  00                DCB      0x00
                  usart2_rcv_len
                          DCD      0x00000000
                  len
                          DCD      0x00000000

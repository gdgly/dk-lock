; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\bsp.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\bsp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\FLib\inc -I..\CORE -I..\driver -I..\BSP -I..\SYS -I..\tplib -IE:\github\dk-lock\src\Proj\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=..\obj\bsp.crf ..\BSP\bsp.c]
                          THUMB

                          AREA ||i.bsp_init||, CODE, READONLY, ALIGN=1

                  bsp_init PROC
;;;289    */
;;;290    void bsp_init(void)
000000  b510              PUSH     {r4,lr}
;;;291    {
;;;292    	bsp_rcc_init();
000002  f7fffffe          BL       bsp_rcc_init
;;;293    	bsp_nvic_init();
000006  f7fffffe          BL       bsp_nvic_init
;;;294    	gpio_init();
00000a  f7fffffe          BL       gpio_init
;;;295    //	iwatchdog_config();
;;;296    	usart1_init(115200, 8, 0, 1);
00000e  2301              MOVS     r3,#1
000010  2200              MOVS     r2,#0
000012  2108              MOVS     r1,#8
000014  f44f30e1          MOV      r0,#0x1c200
000018  f7fffffe          BL       usart1_init
;;;297    	usart2_init(115200);
00001c  f44f30e1          MOV      r0,#0x1c200
000020  f7fffffe          BL       usart2_init
;;;298    //	usart3_init(9600);
;;;299    	USART3_Init(9600); 
000024  f44f5016          MOV      r0,#0x2580
000028  f7fffffe          BL       USART3_Init
;;;300    	timer2_init(200, 40);
00002c  2128              MOVS     r1,#0x28
00002e  20c8              MOVS     r0,#0xc8
000030  f7fffffe          BL       timer2_init
;;;301    //	RTC_Init();
;;;302    //	AT24CXX_Init();   
;;;303    	Adc_Init();
000034  f7fffffe          BL       Adc_Init
;;;304    }
000038  bd10              POP      {r4,pc}
;;;305    
                          ENDP


                          AREA ||i.bsp_nvic_init||, CODE, READONLY, ALIGN=1

                  bsp_nvic_init PROC
;;;240    */
;;;241    void bsp_nvic_init(void)
000000  b508              PUSH     {r3,lr}
;;;242    {
;;;243    	NVIC_InitTypeDef nvic_init_structure;
;;;244    
;;;245    	
;;;246    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000002  f44f60e0          MOV      r0,#0x700
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;247    
;;;248    	// TIM2
;;;249    	nvic_init_structure.NVIC_IRQChannel = TIM2_IRQn;
00000a  201c              MOVS     r0,#0x1c
00000c  f88d0000          STRB     r0,[sp,#0]
;;;250        nvic_init_structure.NVIC_IRQChannelPreemptionPriority = 0;    //
000010  2000              MOVS     r0,#0
000012  f88d0001          STRB     r0,[sp,#1]
;;;251        nvic_init_structure.NVIC_IRQChannelSubPriority = 2;
000016  2002              MOVS     r0,#2
000018  f88d0002          STRB     r0,[sp,#2]
;;;252        nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;253        NVIC_Init(&nvic_init_structure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;254    
;;;255    	
;;;256    	// USART1
;;;257    	nvic_init_structure.NVIC_IRQChannel = USART1_IRQn;
000028  2025              MOVS     r0,#0x25
00002a  f88d0000          STRB     r0,[sp,#0]
;;;258        nvic_init_structure.NVIC_IRQChannelPreemptionPriority = 1;
00002e  2001              MOVS     r0,#1
000030  f88d0001          STRB     r0,[sp,#1]
;;;259        nvic_init_structure.NVIC_IRQChannelSubPriority = 1;
000034  f88d0002          STRB     r0,[sp,#2]
;;;260        nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;	 
000038  f88d0003          STRB     r0,[sp,#3]
;;;261    	NVIC_Init(&nvic_init_structure);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       NVIC_Init
;;;262    	
;;;263    	// USART2
;;;264    	nvic_init_structure.NVIC_IRQChannel = USART2_IRQn;
000042  2026              MOVS     r0,#0x26
000044  f88d0000          STRB     r0,[sp,#0]
;;;265        nvic_init_structure.NVIC_IRQChannelPreemptionPriority = 1;
000048  2001              MOVS     r0,#1
00004a  f88d0001          STRB     r0,[sp,#1]
;;;266        nvic_init_structure.NVIC_IRQChannelSubPriority = 2;
00004e  2002              MOVS     r0,#2
000050  f88d0002          STRB     r0,[sp,#2]
;;;267        nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;	 
000054  2001              MOVS     r0,#1
000056  f88d0003          STRB     r0,[sp,#3]
;;;268    	NVIC_Init(&nvic_init_structure);	
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       NVIC_Init
;;;269    	
;;;270    	// USART3
;;;271    	nvic_init_structure.NVIC_IRQChannel = USART3_IRQn;
000060  2027              MOVS     r0,#0x27
000062  f88d0000          STRB     r0,[sp,#0]
;;;272        nvic_init_structure.NVIC_IRQChannelPreemptionPriority = 1;
000066  2001              MOVS     r0,#1
000068  f88d0001          STRB     r0,[sp,#1]
;;;273        nvic_init_structure.NVIC_IRQChannelSubPriority = 3;
00006c  2003              MOVS     r0,#3
00006e  f88d0002          STRB     r0,[sp,#2]
;;;274        nvic_init_structure.NVIC_IRQChannelCmd = ENABLE;	 
000072  2001              MOVS     r0,#1
000074  f88d0003          STRB     r0,[sp,#3]
;;;275    	NVIC_Init(&nvic_init_structure);	
000078  4668              MOV      r0,sp
00007a  f7fffffe          BL       NVIC_Init
;;;276    }
00007e  bd08              POP      {r3,pc}
;;;277    
                          ENDP


                          AREA ||i.bsp_rcc_init||, CODE, READONLY, ALIGN=1

                  bsp_rcc_init PROC
;;;33     */
;;;34     void bsp_rcc_init(void)
000000  b510              PUSH     {r4,lr}
;;;35     {
;;;36     //	ErrorStatus err_status;
;;;37     
;;;38     //	RCC_DeInit();
;;;39     //	RCC_HSEConfig(RCC_HSE_ON);
;;;40     
;;;41     //	err_status = RCC_WaitForHSEStartUp();
;;;42     
;;;43     //	if (err_status == SUCCESS)
;;;44     //	{        
;;;45     //        /* HCLK = SYSCLK */
;;;46     //        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
;;;47     //        
;;;48     //        /* PCLK2 = HCLK */
;;;49     //        RCC_PCLK2Config(RCC_HCLK_Div1); 
;;;50     //        
;;;51     //        /* PCLK1 = HCLK */
;;;52     //        RCC_PCLK1Config(RCC_HCLK_Div1);
;;;53     //        
;;;54     //        /* PLLCLK = 12MHz * 6 = 72 MHz */
;;;55     //        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_6);
;;;56     //        /* Enable PLL */ 
;;;57     //        RCC_PLLCmd(ENABLE);
;;;58     //	
;;;59     //		while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
;;;60     
;;;61     //		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
;;;62     //        
;;;63     //        /* Wait till PLL is used as system clock source */
;;;64     //        while(RCC_GetSYSCLKSource() != 0x08);
;;;65     //	}
;;;66     
;;;67     
;;;68     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);	
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;69     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	
00000a  2101              MOVS     r1,#1
00000c  0448              LSLS     r0,r1,#17
00000e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;70     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);	
000012  2101              MOVS     r1,#1
000014  0488              LSLS     r0,r1,#18
000016  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;71     	
;;;72     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);
00001a  2101              MOVS     r1,#1
00001c  2004              MOVS     r0,#4
00001e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;73     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
000022  2101              MOVS     r1,#1
000024  2008              MOVS     r0,#8
000026  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;74     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC , ENABLE);
00002a  2101              MOVS     r1,#1
00002c  2010              MOVS     r0,#0x10
00002e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;75     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD , ENABLE);
000032  2101              MOVS     r1,#1
000034  2020              MOVS     r0,#0x20
000036  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;76     	
;;;77     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  0388              LSLS     r0,r1,#14
00003e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;78     	
;;;79     	
;;;80     }
000042  bd10              POP      {r4,pc}
;;;81     
                          ENDP


                          AREA ||i.gpio_init||, CODE, READONLY, ALIGN=2

                  gpio_init PROC
;;;130    */
;;;131    void gpio_init(void)
000000  b508              PUSH     {r3,lr}
;;;132    {
;;;133    	GPIO_InitTypeDef gpio_init_structure;
;;;134    	
;;;135    //	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
;;;136    //	gpio_init_structure.GPIO_Pin = GPIO_Pin_3;				                 //LED1
;;;137    //  	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;138    //  	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
;;;139    //  	GPIO_Init(GPIOB, &gpio_init_structure);	
;;;140    
;;;141    	
;;;142    	// UART1
;;;143    	gpio_init_structure.GPIO_Pin = GPIO_Pin_9;				// UART1 TX				    
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;144      	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;145      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;146      	GPIO_Init(GPIOA, &gpio_init_structure);
000016  4669              MOV      r1,sp
000018  484a              LDR      r0,|L4.324|
00001a  f7fffffe          BL       GPIO_Init
;;;147    	gpio_init_structure.GPIO_Pin = GPIO_Pin_10;				
00001e  f44f6080          MOV      r0,#0x400
000022  f8ad0000          STRH     r0,[sp,#0]
;;;148      	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2004              MOVS     r0,#4
000028  f88d0003          STRB     r0,[sp,#3]
;;;149      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
00002c  2003              MOVS     r0,#3
00002e  f88d0002          STRB     r0,[sp,#2]
;;;150      	GPIO_Init(GPIOA, &gpio_init_structure);
000032  4669              MOV      r1,sp
000034  4843              LDR      r0,|L4.324|
000036  f7fffffe          BL       GPIO_Init
;;;151    	
;;;152    	// UART2
;;;153    	gpio_init_structure.GPIO_Pin = GPIO_Pin_2;				// UART2 TX				    
00003a  2004              MOVS     r0,#4
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;154      	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
000040  2018              MOVS     r0,#0x18
000042  f88d0003          STRB     r0,[sp,#3]
;;;155      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
000046  2003              MOVS     r0,#3
000048  f88d0002          STRB     r0,[sp,#2]
;;;156      	GPIO_Init(GPIOA, &gpio_init_structure);
00004c  4669              MOV      r1,sp
00004e  483d              LDR      r0,|L4.324|
000050  f7fffffe          BL       GPIO_Init
;;;157    	gpio_init_structure.GPIO_Pin = GPIO_Pin_3;				
000054  2008              MOVS     r0,#8
000056  f8ad0000          STRH     r0,[sp,#0]
;;;158      	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00005a  2004              MOVS     r0,#4
00005c  f88d0003          STRB     r0,[sp,#3]
;;;159      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
000060  2003              MOVS     r0,#3
000062  f88d0002          STRB     r0,[sp,#2]
;;;160      	GPIO_Init(GPIOA, &gpio_init_structure);
000066  4669              MOV      r1,sp
000068  4836              LDR      r0,|L4.324|
00006a  f7fffffe          BL       GPIO_Init
;;;161    
;;;162    
;;;163    	// UART3
;;;164    	gpio_init_structure.GPIO_Pin = GPIO_Pin_10;				// UART3 TX				    
00006e  f44f6080          MOV      r0,#0x400
000072  f8ad0000          STRH     r0,[sp,#0]
;;;165      	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
000076  2018              MOVS     r0,#0x18
000078  f88d0003          STRB     r0,[sp,#3]
;;;166      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
00007c  2003              MOVS     r0,#3
00007e  f88d0002          STRB     r0,[sp,#2]
;;;167      	GPIO_Init(GPIOB, &gpio_init_structure);
000082  4669              MOV      r1,sp
000084  4830              LDR      r0,|L4.328|
000086  f7fffffe          BL       GPIO_Init
;;;168    	gpio_init_structure.GPIO_Pin = GPIO_Pin_11;				
00008a  f44f6000          MOV      r0,#0x800
00008e  f8ad0000          STRH     r0,[sp,#0]
;;;169      	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000092  2004              MOVS     r0,#4
000094  f88d0003          STRB     r0,[sp,#3]
;;;170      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
000098  2003              MOVS     r0,#3
00009a  f88d0002          STRB     r0,[sp,#2]
;;;171      	GPIO_Init(GPIOB, &gpio_init_structure);
00009e  4669              MOV      r1,sp
0000a0  4829              LDR      r0,|L4.328|
0000a2  f7fffffe          BL       GPIO_Init
;;;172    	
;;;173    	
;;;174    	
;;;175    	//I2C
;;;176    	gpio_init_structure.GPIO_Pin = GPIO_Pin_0;
0000a6  2001              MOVS     r0,#1
0000a8  f8ad0000          STRH     r0,[sp,#0]
;;;177      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
0000ac  2003              MOVS     r0,#3
0000ae  f88d0002          STRB     r0,[sp,#2]
;;;178    	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_PP;          
0000b2  2010              MOVS     r0,#0x10
0000b4  f88d0003          STRB     r0,[sp,#3]
;;;179      	GPIO_Init(GPIOB, &gpio_init_structure);
0000b8  4669              MOV      r1,sp
0000ba  4823              LDR      r0,|L4.328|
0000bc  f7fffffe          BL       GPIO_Init
;;;180    	
;;;181    	gpio_init_structure.GPIO_Pin = GPIO_Pin_1;
0000c0  2002              MOVS     r0,#2
0000c2  f8ad0000          STRH     r0,[sp,#0]
;;;182      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
0000c6  2003              MOVS     r0,#3
0000c8  f88d0002          STRB     r0,[sp,#2]
;;;183    	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_OD;          
0000cc  2014              MOVS     r0,#0x14
0000ce  f88d0003          STRB     r0,[sp,#3]
;;;184      	GPIO_Init(GPIOB, &gpio_init_structure);
0000d2  4669              MOV      r1,sp
0000d4  481c              LDR      r0,|L4.328|
0000d6  f7fffffe          BL       GPIO_Init
;;;185    	
;;;186    	
;;;187    	//button
;;;188    	gpio_init_structure.GPIO_Pin = GPIO_Pin_6;
0000da  2040              MOVS     r0,#0x40
0000dc  f8ad0000          STRH     r0,[sp,#0]
;;;189      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
0000e0  2003              MOVS     r0,#3
0000e2  f88d0002          STRB     r0,[sp,#2]
;;;190    	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_PP;          
0000e6  2010              MOVS     r0,#0x10
0000e8  f88d0003          STRB     r0,[sp,#3]
;;;191      	GPIO_Init(GPIOC, &gpio_init_structure);
0000ec  4669              MOV      r1,sp
0000ee  4817              LDR      r0,|L4.332|
0000f0  f7fffffe          BL       GPIO_Init
;;;192    	
;;;193    	
;;;194    	
;;;195    	//LOCK ON   OFF
;;;196    	
;;;197    	gpio_init_structure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
0000f4  2030              MOVS     r0,#0x30
0000f6  f8ad0000          STRH     r0,[sp,#0]
;;;198      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
0000fa  2003              MOVS     r0,#3
0000fc  f88d0002          STRB     r0,[sp,#2]
;;;199    	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_PP;          
000100  2010              MOVS     r0,#0x10
000102  f88d0003          STRB     r0,[sp,#3]
;;;200      	GPIO_Init(GPIOA, &gpio_init_structure);
000106  4669              MOV      r1,sp
000108  480e              LDR      r0,|L4.324|
00010a  f7fffffe          BL       GPIO_Init
;;;201    	
;;;202    	//MOTO D+ MOTO D-
;;;203    	gpio_init_structure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
00010e  2003              MOVS     r0,#3
000110  f8ad0000          STRH     r0,[sp,#0]
;;;204      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
000114  f88d0002          STRB     r0,[sp,#2]
;;;205    	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_PP;          
000118  2010              MOVS     r0,#0x10
00011a  f88d0003          STRB     r0,[sp,#3]
;;;206      	GPIO_Init(GPIOC, &gpio_init_structure);
00011e  4669              MOV      r1,sp
000120  480a              LDR      r0,|L4.332|
000122  f7fffffe          BL       GPIO_Init
;;;207    	
;;;208    	//BELL
;;;209    	gpio_init_structure.GPIO_Pin = GPIO_Pin_3;
000126  2008              MOVS     r0,#8
000128  f8ad0000          STRH     r0,[sp,#0]
;;;210      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
00012c  2003              MOVS     r0,#3
00012e  f88d0002          STRB     r0,[sp,#2]
;;;211    	gpio_init_structure.GPIO_Mode = GPIO_Mode_Out_PP;          
000132  2010              MOVS     r0,#0x10
000134  f88d0003          STRB     r0,[sp,#3]
;;;212      	GPIO_Init(GPIOC, &gpio_init_structure);
000138  4669              MOV      r1,sp
00013a  4804              LDR      r0,|L4.332|
00013c  f7fffffe          BL       GPIO_Init
;;;213    }
000140  bd08              POP      {r3,pc}
;;;214    
                          ENDP

000142  0000              DCW      0x0000
                  |L4.324|
                          DCD      0x40010800
                  |L4.328|
                          DCD      0x40010c00
                  |L4.332|
                          DCD      0x40011000

                          AREA ||i.iwatchdog_clear||, CODE, READONLY, ALIGN=1

                  iwatchdog_clear PROC
;;;114    */
;;;115    void iwatchdog_clear(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117    	IWDG_ReloadCounter();
000002  f7fffffe          BL       IWDG_ReloadCounter
;;;118    }
000006  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.iwatchdog_config||, CODE, READONLY, ALIGN=1

                  iwatchdog_config PROC
;;;94     */
;;;95     void iwatchdog_config(void)
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97     	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
000002  f2455055          MOV      r0,#0x5555
000006  f7fffffe          BL       IWDG_WriteAccessCmd
;;;98     	IWDG_SetPrescaler(IWDG_Prescaler_256);
00000a  2006              MOVS     r0,#6
00000c  f7fffffe          BL       IWDG_SetPrescaler
;;;99     	IWDG_SetReload(0xFFE);
000010  f64070fe          MOV      r0,#0xffe
000014  f7fffffe          BL       IWDG_SetReload
;;;100    	IWDG_ReloadCounter();
000018  f7fffffe          BL       IWDG_ReloadCounter
;;;101    	IWDG_Enable();		
00001c  f7fffffe          BL       IWDG_Enable
;;;102    }
000020  bd10              POP      {r4,pc}
;;;103    
                          ENDP


                          AREA ||i.lock_off||, CODE, READONLY, ALIGN=2

                  lock_off PROC
;;;221    
;;;222    void lock_off(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224    	MOTOB_HIGH();
000002  2102              MOVS     r1,#2
000004  4803              LDR      r0,|L7.20|
000006  f7fffffe          BL       GPIO_SetBits
;;;225    	MOTOA_LOW();
00000a  2101              MOVS     r1,#1
00000c  4801              LDR      r0,|L7.20|
00000e  f7fffffe          BL       GPIO_ResetBits
;;;226    }
000012  bd10              POP      {r4,pc}
;;;227    
                          ENDP

                  |L7.20|
                          DCD      0x40011000

                          AREA ||i.lock_on||, CODE, READONLY, ALIGN=2

                  lock_on PROC
;;;215    
;;;216    void lock_on(void)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218    	MOTOA_LOW();
000002  2101              MOVS     r1,#1
000004  4803              LDR      r0,|L8.20|
000006  f7fffffe          BL       GPIO_ResetBits
;;;219    	MOTOB_HIGH();
00000a  2102              MOVS     r1,#2
00000c  4801              LDR      r0,|L8.20|
00000e  f7fffffe          BL       GPIO_SetBits
;;;220    }
000012  bd10              POP      {r4,pc}
;;;221    
                          ENDP

                  |L8.20|
                          DCD      0x40011000

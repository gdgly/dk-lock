; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\main.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\FLib\inc -I..\CORE -I..\driver -I..\BSP -I..\SYS -I..\tplib -IE:\github\HH-1\HH\Proj\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=..\obj\main.crf ..\USER\main.c]
                          THUMB

                          AREA ||i.Gps_Msg_Show||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_f
                          REQUIRE _printf_c
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  Gps_Msg_Show PROC
;;;93     
;;;94     void Gps_Msg_Show(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;95     {
;;;96      	float tp;		   
;;;97      
;;;98     	tp=gpsx.longitude;	   
000002  492b              LDR      r1,|L1.176|
000004  f8d10086          LDR      r0,[r1,#0x86]  ; gpsx
000008  f7fffffe          BL       __aeabi_ui2f
00000c  4607              MOV      r7,r0
;;;99     	sprintf((char *)longitudedtbuf,"%clongitude%c:%.5f %1c",'"','"',tp/=100000,gpsx.ewhemi);	
00000e  4929              LDR      r1,|L1.180|
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       __aeabi_fdiv
000016  4607              MOV      r7,r0
000018  4604              MOV      r4,r0
00001a  f7fffffe          BL       __aeabi_f2d
00001e  4605              MOV      r5,r0
000020  4823              LDR      r0,|L1.176|
000022  f890008a          LDRB     r0,[r0,#0x8a]  ; gpsx
000026  2322              MOVS     r3,#0x22
000028  461a              MOV      r2,r3
00002a  e9cd5100          STRD     r5,r1,[sp,#0]
00002e  9002              STR      r0,[sp,#8]
000030  a121              ADR      r1,|L1.184|
000032  4827              LDR      r0,|L1.208|
000034  f7fffffe          BL       __2sprintf
;;;100    	//USART_OUT("%s\r\n",dtbuf);	 	
;;;101    	USART_OUT(USART1,"%s\r\n",longitudedtbuf);	
000038  4a25              LDR      r2,|L1.208|
00003a  a126              ADR      r1,|L1.212|
00003c  4827              LDR      r0,|L1.220|
00003e  f7fffffe          BL       USART_OUT
;;;102    	tp=gpsx.latitude;	   
000042  491b              LDR      r1,|L1.176|
000044  f8d10081          LDR      r0,[r1,#0x81]  ; gpsx
000048  f7fffffe          BL       __aeabi_ui2f
00004c  4607              MOV      r7,r0
;;;103    	sprintf((char *)latitudedtbuf,"%clatitude%c:%.5f %1c",'"','"',tp/=100000,gpsx.nshemi);	
00004e  4919              LDR      r1,|L1.180|
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       __aeabi_fdiv
000056  4607              MOV      r7,r0
000058  4604              MOV      r4,r0
00005a  f7fffffe          BL       __aeabi_f2d
00005e  4605              MOV      r5,r0
000060  4813              LDR      r0,|L1.176|
000062  f8900085          LDRB     r0,[r0,#0x85]  ; gpsx
000066  2322              MOVS     r3,#0x22
000068  461a              MOV      r2,r3
00006a  e9cd5100          STRD     r5,r1,[sp,#0]
00006e  9002              STR      r0,[sp,#8]
000070  a11b              ADR      r1,|L1.224|
000072  4821              LDR      r0,|L1.248|
000074  f7fffffe          BL       __2sprintf
;;;104    	USART_OUT(USART1,"%s\r\n",latitudedtbuf);
000078  4a1f              LDR      r2,|L1.248|
00007a  a116              ADR      r1,|L1.212|
00007c  4817              LDR      r0,|L1.220|
00007e  f7fffffe          BL       USART_OUT
;;;105    	tp=gpsx.altitude;	   
000082  490b              LDR      r1,|L1.176|
000084  f8d100a0          LDR      r0,[r1,#0xa0]  ; gpsx
000088  f7fffffe          BL       __aeabi_i2f
00008c  4607              MOV      r7,r0
;;;106     	sprintf((char *)dtbuf,"Altitude:%.1fm     ",tp/=10);	    			
00008e  491b              LDR      r1,|L1.252|
000090  4638              MOV      r0,r7
000092  f7fffffe          BL       __aeabi_fdiv
000096  4607              MOV      r7,r0
000098  4604              MOV      r4,r0
00009a  f7fffffe          BL       __aeabi_f2d
00009e  4605              MOV      r5,r0
0000a0  462a              MOV      r2,r5
0000a2  460b              MOV      r3,r1
0000a4  a116              ADR      r1,|L1.256|
0000a6  481b              LDR      r0,|L1.276|
0000a8  f7fffffe          BL       __2sprintf
;;;107    }
0000ac  bdfe              POP      {r1-r7,pc}
;;;108    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L1.176|
                          DCD      gpsx
                  |L1.180|
                          DCD      0x47c35000
                  |L1.184|
0000b8  25636c6f          DCB      "%clongitude%c:%.5f %1c",0
0000bc  6e676974
0000c0  75646525
0000c4  633a252e
0000c8  35662025
0000cc  316300  
0000cf  00                DCB      0
                  |L1.208|
                          DCD      longitudedtbuf
                  |L1.212|
0000d4  25730d0a          DCB      "%s\r\n",0
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L1.220|
                          DCD      0x40013800
                  |L1.224|
0000e0  25636c61          DCB      "%clatitude%c:%.5f %1c",0
0000e4  74697475
0000e8  64652563
0000ec  3a252e35
0000f0  66202531
0000f4  6300    
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L1.248|
                          DCD      latitudedtbuf
                  |L1.252|
                          DCD      0x41200000
                  |L1.256|
000100  416c7469          DCB      "Altitude:%.1fm     ",0
000104  74756465
000108  3a252e31
00010c  666d2020
000110  20202000
                  |L1.276|
                          DCD      dtbuf

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;110    
;;;111    int main(void)
000000  bf00              NOP      
;;;112    { 
;;;113    	u16 j,i,rxlen;
;;;114    	u16 k=0;
;;;115    	u8 upload=0; 	
000002  bf00              NOP      
;;;116    	bsp_init();
000004  f7fffffe          BL       bsp_init
;;;117    
;;;118    
;;;119    	USART_OUT(USART1, "uart1 is ok\r\n");
000008  a10b              ADR      r1,|L2.56|
00000a  480f              LDR      r0,|L2.72|
00000c  f7fffffe          BL       USART_OUT
;;;120    	
;;;121    	
;;;122    	USART_OUT(USART1, "wangzhongya\r\n");
000010  a10e              ADR      r1,|L2.76|
000012  480d              LDR      r0,|L2.72|
000014  f7fffffe          BL       USART_OUT
;;;123    	
;;;124    
;;;125    //	while(1)
;;;126    //	{
;;;127    //		USART_OUT(USART1, "123465\r\n");
;;;128    //		if(USART3_RX_STA&0X8000)		
;;;129    //		{
;;;130    //			rxlen=USART3_RX_STA&0X7FFF;	
;;;131    //			for(i=0;i<rxlen;i++)USART1_TX_BUF[i]=USART3_RX_BUF[i];	   
;;;132    //			
;;;133    //			USART3_RX_STA=0;		   	
;;;134    //			USART1_TX_BUF[i]=0;			
;;;135    //			GPS_Analysis(&gpsx,(u8*)USART1_TX_BUF);
;;;136    //			Gps_Msg_Show();		
;;;137    //			if(upload)USART_OUT(USART1,"\r\n%s\r\n",USART1_TX_BUF);
;;;138    //			
;;;139    //			if(gpsx.latitude>0&&gpsx.longitude>0)
;;;140    //			{
;;;141    //					memset(expressText, 0 ,1024);
;;;142    //					sprintf((char *)expressText,"%c%s,%s%c",'{',(char *)longitudedtbuf,(char *)latitudedtbuf,'}',48);
;;;143    //					sprintf((char *)PublishDataGpsbuf,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",64,2\r\n");	
;;;144    ////				    SendCmd((char *)PublishDataGpsbuf,">",20);
;;;145    //					gprs_send_at(PublishDataGpsbuf, ">", 200, 10000);
;;;146    ////					myfree(PublishDataGpsbuf);				
;;;147    //					//SendCmd((char *)localbuf,"OK",10);//
;;;148    //					memset(cipherText, 0 ,1024);
;;;149    //					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;150    //					SendCmd((char *)cipherText,"OK",20);//
;;;151    //					USART_OUT(USART1, "local:%s\r\n",expressText);	
;;;152    //				  Gps_longi=gpsx.longitude;
;;;153    //				  Gps_Lati=gpsx.latitude;
;;;154    //				break;
;;;155    
;;;156    //				 
;;;157    //			}
;;;158    //		}
;;;159    //		else
;;;160    //		{
;;;161    //			k++;
;;;162    //			timer_delay_1ms(1000);
;;;163    //		//	BEEP=1;
;;;164    //			if(k>10)
;;;165    //			{
;;;166    //				break;
;;;167    //			}
;;;168    //		}
;;;169    //		usart1_recv_data();
;;;170    
;;;171    //		usart2_recv_data();	
;;;172    //  }
;;;173    
;;;174    	while(1)
000018  e00d              B        |L2.54|
                  |L2.26|
;;;175    	{	 
;;;176    
;;;177    		while(1)
00001a  e006              B        |L2.42|
                  |L2.28|
;;;178    		{
;;;179    			gprs_config();
00001c  f7fffffe          BL       gprs_config
;;;180    			if(gprs_status == 255)
000020  480e              LDR      r0,|L2.92|
000022  7800              LDRB     r0,[r0,#0]  ; gprs_status
000024  28ff              CMP      r0,#0xff
000026  d100              BNE      |L2.42|
;;;181    			{
;;;182    				break;
000028  e000              B        |L2.44|
                  |L2.42|
00002a  e7f7              B        |L2.28|
                  |L2.44|
00002c  bf00              NOP      
;;;183    			}
;;;184    		}
;;;185    		usart1_recv_data();
00002e  f7fffffe          BL       usart1_recv_data
;;;186    		usart2_recv_data();
000032  f7fffffe          BL       usart2_recv_data
                  |L2.54|
000036  e7f0              B        |L2.26|
;;;187    		
;;;188    		
;;;189    		// 电池信息
;;;190    //		Bat_V =Get_Adc_Average(ADC_Channel_0,10);
;;;191    //		Bat_V=Bat_V*3300/4096;
;;;192    //		Bat_V=Bat_V*88/20;
;;;193    //		Bat_Pre=(Bat_V-5000)*100/2400;
;;;194    //		if(Bat_Pre<20&&Bat_Pre>10&&Bat_Pre_Flag==0)
;;;195    //		{
;;;196    //			Bat_Pre_Flag=1;
;;;197    //			sprintf((char *)PublishDataBatbuf,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",24,2\r\n");
;;;198    //			SendCmd((char *)PublishDataBatbuf,">",20);
;;;199    //			timer_delay_1ms(10);
;;;200    //			memset(expressText, 0 ,1024);
;;;201    //			sprintf((char *)expressText,"{%c%s%c:%s}",'"',"battery",'"',"20");
;;;202    //			memset(cipherText, 0 ,1024);
;;;203    //			AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;204    //			SendCmd((char *)cipherText,"OK",20);//
;;;205    //			//SendCmd((char *)bat_buff,"OK",20);//
;;;206    //		}
;;;207    //		
;;;208    //		if(Bat_Pre<10&&Bat_Pre_Flag==1)
;;;209    //		{
;;;210    //			Bat_Pre_Flag=0;
;;;211    //			
;;;212    //			sprintf((char *)PublishDataBatbuf,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",24,2\r\n");
;;;213    //			SendCmd((char *)PublishDataBatbuf,">",20);
;;;214    //			timer_delay_1ms(10);
;;;215    //			memset(expressText, 0 ,1024);
;;;216    //			sprintf((char *)expressText,"{%c%s%c:%s}",'"',"battery",'"',"10");
;;;217    //			memset(cipherText, 0 ,1024);
;;;218    //			AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;219    //			SendCmd((char *)cipherText,"OK",20);//
;;;220    //			
;;;221    //		}
;;;222    		
;;;223    //		
;;;224    //		p1=strstr((u8 *)usart2_rcv_buf,"topic: lock/");
;;;225    //		p2=strstr((u8 *)p1,(u8 *)PARK_LOCK_Buffer);
;;;226    
;;;227    ////		USART_OUT(USART1,"usart_p1:%s\r\n",p1);
;;;228    //		
;;;229    ////		USART_OUT(USART1, "usart_p2:%s\r\n",p2);
;;;230    //		if(strncmp((char *)p1,(char *)"topic: lock/",12)==0)
;;;231    //		{		
;;;232    //			if(LOCK_OFF==0||LOCK_ON==0)
;;;233    //			{			
;;;234    //		if(strncmp((char *)p1,(char *)"topic: lock/",12)==0)
;;;235    //		{	
;;;236    //			USART_OUT(USART1, "p1:%s\r\n",p1+33);
;;;237    //			strcpy(receiveText ,(char *)(p1+33));
;;;238    //			USART_OUT(USART1, "ci:%s\r\n",receiveText);
;;;239    //			memset(expressText ,0 ,1024);
;;;240    //			AES_Decrypt(expressText ,receiveText, aesKey);
;;;241    //			Shaking=1;	
;;;242    //		    USART_OUT(USART1, "ex:%s\r\n",expressText);
;;;243    //				USART_OUT(USART1, "aeskey:%s\r\n",aesKey);
;;;244    //				
;;;245    //					if(*expressText==0x31)
;;;246    //					{
;;;247    ////						USART_OUT("p2:%s\r\n",p2);	
;;;248    //						if(LOCK_ON==0)
;;;249    //						{
;;;250    //						USART_OUT(USART1, "p2:%s\r\n",p2);	
;;;251    //						Lock_Open=1; 
;;;252    //						Lock_Open_Tim5s=calendar.sec;
;;;253    //						Lock_Open_On=1;
;;;254    //						}
;;;255    //						else
;;;256    //						{
;;;257    //							Lock_Open=0;
;;;258    //						}
;;;259    //					}
;;;260    //					else if(*expressText==0x32)
;;;261    //					{
;;;262    //						if(LOCK_OFF==0)
;;;263    //						{
;;;264    //						Lock_Close=1;
;;;265    //						Lock_Close_Tim5s=calendar.sec;
;;;266    //						Lock_Close_On=1;
;;;267    //						}
;;;268    //						else
;;;269    //						{
;;;270    //						Lock_Close=0;
;;;271    //						}
;;;272    //					}	 
;;;273    //					else if(*expressText==0x30)
;;;274    //					{
;;;275    //						Park_Lock_stop();
;;;276    //					}	
;;;277    //			USART2_Clear();
;;;278    //			p1="\0";		
;;;279    ////			myfree(p2);
;;;280    ////			myfree(p4);
;;;281    ////			myfree(p3);
;;;282    ////			myfree(p1);	
;;;283    //			}
;;;284    //			}
;;;285    //		}
;;;286    //		
;;;287    //		if(LOCK_OFF==1||LOCK_ON==1)
;;;288    //		{
;;;289    //			if(strncmp((char *)p1,"topic: lock",11)==0)
;;;290    //			{	
;;;291    //					USART2_Clear();
;;;292    //					p1="\0";		
;;;293    ////					myfree(p2);
;;;294    ////					myfree(p1);	
;;;295    //			}
;;;296    //		}
;;;297    //		
;;;298    //		p3=strstr((char *)usart2_rcv_buf,"topic: bell/");
;;;299    ////		USART_OUT(USART1, "usart_p3:%s\r\n",p3);
;;;300    //		p4=strstr((char *)p3,(char *)PARK_LOCK_Buffer);
;;;301    //				
;;;302    ////		USART_OUT(USART1, "usart_p4:%s\r\n",p4);
;;;303    //	//if(strncmp((char *)p4,(char *)PARK_LOCK_Buffer,8)==0)					
;;;304    //	//p1=strstr((char *)usart2_rcv_buf,"topic");
;;;305    //		if(strncmp((char *)p3,"topic: bell/",12)==0&&bell_flag==0)
;;;306    //		//if(strncmp((char *)p4,(char *)PARK_LOCK_Buffer,16)==0&&bell_flag==0)
;;;307    //		{		
;;;308    //			bell_flag=1;
;;;309    //			USART_OUT(USART1, "p1:%s\r\n",p4);			
;;;310    ////			YELLOW_LED=1;
;;;311    ////			BEEP=1;
;;;312    //			BEEP_HIGH();
;;;313    
;;;314    //			//p1="\0";
;;;315    //			USART2_Clear();
;;;316    ////
;;;317    //			
;;;318    //			timer_delay_1ms(2000);
;;;319    ////			YELLOW_LED=0;
;;;320    ////			BEEP=0;
;;;321    //			BEEP_LOW();
;;;322    //		}
;;;323    //	  if(bell_flag==1)
;;;324    //		{
;;;325    //			bell_flag=0;
;;;326    //		}
;;;327    //		  //USART2_Clear();
;;;328    //			//myfree(usart2_rcv_buf);
;;;329    //			//myfree(p1);
;;;330    //			//myfree(p2);
;;;331    //			//myfree(p3);
;;;332    //			//myfree(p4);
;;;333    //			//usart2_rcv_len=0;
;;;334    //			timer_delay_1ms(10);
;;;335    
;;;336    
;;;337    //		if(Lock_Open==1) 
;;;338    //		{
;;;339    //			Lock_Open=0;
;;;340    //			
;;;341    //			Park_Lock_Open();
;;;342    //		}
;;;343    
;;;344    //    if(Lock_Close==1)  
;;;345    //		{
;;;346    //			Lock_Close=0;
;;;347    //		
;;;348    //			Park_Lock_Close();
;;;349    //		}
;;;350    //		
;;;351    
;;;352    //		//key=KEY_Scan(0);
;;;353    //		if((LOCK_ON==0)&&(LOCK_OFF_flag==0)&&(flag==4)&&Hand_Flag==0)
;;;354    //		{		
;;;355    //      Shaking=0;			
;;;356    //			self_calendar.self_w_date=calendar.w_date;
;;;357    //			self_calendar.self_hour=calendar.hour;
;;;358    //			self_calendar.self_min=calendar.min;
;;;359    //		  self_calendar.self_flag=0;
;;;360    //			//IWDG_Feed();	
;;;361    //			
;;;362    //		  Park_Lock_stop();
;;;363    //			if(Shaking_Alarm_Flag==0)
;;;364    //			{
;;;365    //				if(Lock_Open_Off==1)
;;;366    //				{
;;;367    //					sprintf((char *)PublishLockBackbuf,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");	
;;;368    //					SendCmd((char *)PublishLockBackbuf,">",20);//
;;;369    
;;;370    ////					myfree(PublishLockBackbuf);
;;;371    ////					timer_delay_1ms(30);
;;;372    //					//SendCmd("AT+PUBLISH=lockback/00010002,16,2\r\n",">",20);
;;;373    //					memset(expressText , 0 ,1024);
;;;374    //					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"1");
;;;375    //					memset(cipherText, 0 ,1024);
;;;376    //          AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;377    //					SendCmd((char *)cipherText,"OK",20);//
;;;378    //					//SendCmd((char *)lockbuf,"OK",20);//
;;;379    //				}
;;;380    //				if(Lock_Open_Off==0)
;;;381    //				{
;;;382    //					sprintf((char *)PublishLockBackbuf,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");		
;;;383    //					SendCmd((char *)PublishLockBackbuf,">",20);//
;;;384    ////						myfree(PublishLockBackbuf);
;;;385    ////					timer_delay_1ms(30);
;;;386    //				//	SendCmd("AT+PUBLISH=lockback/00010002,16,2\r\n",">",20);
;;;387    //					memset(expressText , 0 ,1024);
;;;388    //					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"0");//10
;;;389    //					USART_OUT(USART1, "cmd:%s\r\n",expressText);
;;;390    //					memset(cipherText , 0 ,1024);
;;;391    //					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;392    //					SendCmd((char *)cipherText,"OK",20);//
;;;393    //					//SendCmd((char *)lockbuff,"OK",20);//
;;;394    ////					BEEP=1;
;;;395    //					BEEP_HIGH();
;;;396    //					timer_delay_1ms(20);
;;;397    //					BEEP_LOW();
;;;398    //				}
;;;399    //		  }
;;;400    //			Lock_Open_Off=0;
;;;401    //			Lock_Open_On=0;
;;;402    //			Lock_Close_On=0;
;;;403    //			USART_OUT(USART1, "lockback_on\r\n");
;;;404    //			
;;;405    ////			myfree((char *)lockbuf);
;;;406    ////			myfree((char *)lockbuff);
;;;407    //			LOCK_OFF_flag=1;
;;;408    //		}
;;;409    //		else if(LOCK_ON==1)
;;;410    //		{
;;;411    //			LOCK_OFF_flag=0;
;;;412    //		}
;;;413    //		if(Lock_Close_On==1)
;;;414    //		{
;;;415    //			u8 temp=calendar.sec;
;;;416    //			if(temp>=Lock_Close_Tim5s)
;;;417    //			{
;;;418    //				if((temp-Lock_Close_Tim5s)>5)//关锁超时
;;;419    //				{
;;;420    //					Lock_Close_On=0;
;;;421    //					Park_Lock_Open();
;;;422    //					Lock_Close_Off=1;
;;;423    //				}
;;;424    //			}
;;;425    //			else
;;;426    //			{
;;;427    //				if((temp+60-Lock_Close_Tim5s)>5)//关锁超时
;;;428    //				{
;;;429    //					Lock_Close_On=0;
;;;430    //					Park_Lock_Open();
;;;431    //					Lock_Close_Off=1;
;;;432    //				}		
;;;433    //			}		
;;;434    //		}
;;;435    ////			IWDG_Feed();	
;;;436    //		//开锁返回开锁1的返回命令
;;;437    //	 if((LOCK_OFF==0)&&(LOCK_ON_flag==0)&&(flag==4))//正常开锁对应1
;;;438    //		{
;;;439    //			 Shaking=0;	//晃动排除	
;;;440    //			//自检时间标定
;;;441    //			self_calendar.self_w_date=calendar.w_date;
;;;442    //			self_calendar.self_hour=calendar.hour;
;;;443    //			self_calendar.self_min=calendar.min;
;;;444    //			self_calendar.self_flag=0;
;;;445    
;;;446    //			
;;;447    //			Park_Lock_stop();
;;;448    //			if(Shaking_Alarm_Flag==0)//晃动报警和自检
;;;449    //			{
;;;450    //				if(Lock_Close_Off==1)
;;;451    //				{
;;;452    //					sprintf((char *)PublishLockBackbuf,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");							
;;;453    //	        SendCmd((char *)PublishLockBackbuf,">",20);//
;;;454    ////					myfree(PublishLockBackbuf);
;;;455    //					//timer_delay_1ms(30);
;;;456    //					memset(expressText , 0 ,1024);
;;;457    //					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"1");	
;;;458    //					
;;;459    //					//SendCmd("AT+PUBLISH=lockback/00010002,16,2\r\n",">",20);
;;;460    //					memset(cipherText , 0 ,1024);
;;;461    //          AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;462    //					SendCmd((char *)cipherText,"OK",20);//
;;;463    //					//SendCmd((char *)lockbuf,"OK",20);//
;;;464    //				}
;;;465    //				if(Lock_Close_Off==0)
;;;466    //				{
;;;467    //					sprintf((char *)PublishLockBackbuf,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;468    //			    SendCmd((char *)PublishLockBackbuf,">",20);//
;;;469    ////					myfree(PublishLockBackbuf);
;;;470    //					
;;;471    //				//	SendCmd("AT+PUBLISH=lockback/00010002,16,2\r\n",">",20);
;;;472    //					memset(expressText , 0 ,1024);
;;;473    //					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"0");
;;;474    //					
;;;475    //					memset(cipherText , 0 ,1024);
;;;476    //          AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;477    //					SendCmd((char *)cipherText,"OK",20);//
;;;478    //					//SendCmd((char *)lockbuff,"OK",20);//
;;;479    //					USART_OUT(USART1, "ca_off:%d\r\n",calendar.sec);
;;;480    ////					BEEP=1;
;;;481    //					BEEP_HIGH();
;;;482    //					timer_delay_1ms(10);
;;;483    ////					BEEP=0;
;;;484    //					BEEP_LOW();
;;;485    //				}
;;;486    //			}
;;;487    //			Lock_Open_Off=0;
;;;488    //			Lock_Open_On=0;
;;;489    //			Lock_Close_Off=0;
;;;490    //			Lock_Close_On=0;
;;;491    //			//停止低电压
;;;492    ////			myfree((char *)lockbuf);
;;;493    ////			myfree((char *)lockbuff);
;;;494    //			LOCK_ON_flag=1;
;;;495    //		}
;;;496    //		else if(LOCK_OFF==1)
;;;497    //		{
;;;498    //			LOCK_ON_flag=0;
;;;499    //		}
;;;500    //		
;;;501    //		//超时检测
;;;502    //		if(Lock_Open_On==1)
;;;503    //		{
;;;504    //			u8 temp=calendar.sec;
;;;505    //			if(temp>=Lock_Open_Tim5s)
;;;506    //			{
;;;507    //				if((temp-Lock_Open_Tim5s)>3)//开锁超时
;;;508    //				{
;;;509    //					Lock_Open_On=0;
;;;510    //					Park_Lock_Close();
;;;511    //					Lock_Open_Off=1;
;;;512    //				}
;;;513    //			}
;;;514    //			else
;;;515    //			{
;;;516    //				if((temp+60-Lock_Open_Tim5s)>3)//开锁超时
;;;517    //				{
;;;518    //					Lock_Open_On=0;
;;;519    //					Park_Lock_Close();
;;;520    //					Lock_Open_Off=1;
;;;521    //				}		
;;;522    //			}		
;;;523    //		}
;;;524    //		/*//	自检功能
;;;525    //		if(calendar.w_date>self_calendar.self_w_date)
;;;526    //		{
;;;527    //		if((calendar.w_date-self_calendar.self_w_date==2)&&(self_calendar.self_flag==0)&&(calendar.sec==0)&&(calendar.min==0))//
;;;528    //		{
;;;529    //			Self_Check();
;;;530    //			self_calendar.self_flag=1;
;;;531    //			flag=0;
;;;532    //		}	
;;;533    //		}
;;;534    //		timer_delay_1ms(10);*/
;;;535    //		
;;;536    //		
;;;537    //		////////////发布信息地锁经纬度
;;;538    //		//if(calendar.sec==0&&second_flag==0)//24小时检测一次
;;;539    //		if(calendar.sec==0&&second_flag==0&&calendar.hour==0&&calendar.min==0)//24小时检测一次
;;;540    //		{
;;;541    ////			GPS_POW_EN=1;
;;;542    //			GPS_POW_HIGH();
;;;543    //			second_flag=1;
;;;544    //			if(USART3_RX_STA&0X8000)		
;;;545    //			{
;;;546    //				rxlen=USART3_RX_STA&0X7FFF;	
;;;547    //				for(i=0;i<rxlen;i++)USART1_TX_BUF[i]=USART3_RX_BUF[i];	   
;;;548    //				USART3_RX_STA=0;		   
;;;549    //				USART1_TX_BUF[i]=0;			
;;;550    //				GPS_Analysis(&gpsx,(u8*)USART1_TX_BUF);
;;;551    //				Gps_Msg_Show();				
;;;552    //				if(upload)USART_OUT(USART1,"\r\n%s\r\n",USART1_TX_BUF);
;;;553    //			}
;;;554    //			if(gpsx.latitude>0&&gpsx.longitude>0)
;;;555    //				{
;;;556    //					/*
;;;557    //					myfree(Gps_Lati_At24C_Read);
;;;558    //					myfree(Gps_Longi_At24C_Read);
;;;559    //					USART_OUT("str:%s\r\n",(char *)Gps_Longi_At24C_Read);
;;;560    //					AT24CXX_Read(0,(u8 *)Gps_Longi_At24C_Read,8);
;;;561    //					AT24CXX_Read(1,(u8 *)Gps_Lati_At24C_Read,7);
;;;562    //					USART_OUT("str:%s\r\n",(char *)Gps_Longi_At24C_Read);
;;;563    //					Gps_longi=atol(Gps_Longi_At24C_Read);
;;;564    //					Gps_Lati=atol(Gps_Lati_At24C_Read);
;;;565    //					USART_OUT("12345:%ld\r\n",Gps_longi);
;;;566    //					USART_OUT("6789:%ld\r\n",(long)gpsx.longitude);*/
;;;567    ////					if((labs(Gps_longi-gpsx.longitude)>5000)||(labs(Gps_Lati-gpsx.latitude)>5000))
;;;568    ////					{
;;;569    //						memset(expressText, 0 ,1024);
;;;570    //						sprintf((char *)expressText,"%c%s,%s%c",'{',(char *)longitudedtbuf,(char *)latitudedtbuf,'}',48);
;;;571    //						sprintf((char *)PublishDataGpsbuf,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",64,2\r\n");
;;;572    //						
;;;573    //					//SendCmd("AT+PUBLISH=lockdata/00010002,78,2\r\n",">",10);		
;;;574    //						SendCmd((char *)PublishDataGpsbuf,">",20);
;;;575    ////						myfree(PublishDataGpsbuf);				
;;;576    //						//SendCmd((char *)localbuf,"OK",10);//
;;;577    //						memset(cipherText, 0 ,1024);
;;;578    //						AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;579    //						SendCmd((char *)cipherText,"OK",20);//
;;;580    //						USART_OUT(USART1, "local:%s\r\n",expressText);	
;;;581    ////					}
;;;582    ////					GPS_POW_EN=0;
;;;583    //					GPS_POW_LOW();
;;;584    //		   }		
;;;585    //			//Self_Check();
;;;586    
;;;587    //				//USART_OUT("str:%s\r\n",expressText);
;;;588    //		}
;;;589    //		else if(calendar.sec!=0)
;;;590    //		{
;;;591    //			second_flag=0;	
;;;592    //		}
;;;593    
;;;594    ////		USART_OUT(USART1, "sec:%d\r\n",calendar.sec);
;;;595    //		Hand_Lock();
;;;596    
;;;597    //		if((LOCK_OFF==1&&LOCK_ON==1)&&(Shaking==0))
;;;598    //		{
;;;599    //			//USART_OUT("123456");
;;;600    //			Shaking_Alarm_Flag=1;
;;;601    ////			BEEP=1;
;;;602    //			BEEP_HIGH();
;;;603    //		}
;;;604    //		else
;;;605    //		{
;;;606    //			Shaking_Alarm_Flag=0;
;;;607    ////			BEEP=0;
;;;608    //			BEEP_LOW();
;;;609    //		}
;;;610    //		
;;;611    		
;;;612    		
;;;613    	}	 
;;;614    }
;;;615     
                          ENDP

                  |L2.56|
000038  75617274          DCB      "uart1 is ok\r\n",0
00003c  31206973
000040  206f6b0d
000044  0a00    
000046  00                DCB      0
000047  00                DCB      0
                  |L2.72|
                          DCD      0x40013800
                  |L2.76|
00004c  77616e67          DCB      "wangzhongya\r\n",0
000050  7a686f6e
000054  6779610d
000058  0a00    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L2.92|
                          DCD      gprs_status

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  USART1_TX_BUF
                          %        512
                  cipherText
                          %        512
                  receiveText
                          %        24
                  expressText
                          %        512
                  aesKey
                          %        16
                  PublishLockBackbuf
                          %        35
                  PublishDataBatbuf
                          %        35
                  PublishDataGpsbuf
                          %        45
                  PublishDataSelfCheckbuf
                          %        35
                  gpsx
                          %        166
                  longitudedtbuf
                          %        30
                  latitudedtbuf
                          %        30
                  dtbuf
                          %        50
                  self_calendar
                          %        10
                  lockbuf
                          %        16
                  lockbuff
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  Gps_Longi_At24C
                          %        8
                  Gps_Lati_At24C
                          DCD      0x00000000
00000c  000000            DCB      0x00,0x00,0x00
                  Gps_Longi_At24C_Read
00000f  00                DCB      0x00
                          DCD      0x00000000
000014  000000            DCB      0x00,0x00,0x00
                  Gps_Lati_At24C_Read
000017  00                DCB      0x00
                          DCD      0x00000000
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                  Gps_longi
                          DCD      0x00000000
                  Gps_Lati
                          DCD      0x00000000
                  bell_flag
000028  00                DCB      0x00
                  Shaking
000029  00                DCB      0x00
                  Shaking_Alarm_Flag
00002a  0000              DCB      0x00,0x00
                  Bat_V
00002c  0000              DCB      0x00,0x00
                  Bat_Pre
00002e  0000              DCB      0x00,0x00
                  Bat_Pre_Flag
000030  00000000          DCB      0x00,0x00,0x00,0x00
                  ||p1||
                          DCD      0x00000000
                  ||p2||
                          DCD      0x00000000
                  ||p3||
                          DCD      0x00000000
                  ||p4||
                          DCD      0x00000000
                  ||p5||
                          DCD      0x00000000
                  Lock_Open
000048  00                DCB      0x00
                  Lock_Open_On
000049  00                DCB      0x00
                  Lock_Open_Off
00004a  00                DCB      0x00
                  Lock_Open_Tim5s
00004b  00                DCB      0x00
                  Lock_Close
00004c  00                DCB      0x00
                  Lock_Close_On
00004d  00                DCB      0x00
                  Lock_Close_Off
00004e  00                DCB      0x00
                  Lock_Close_Tim5s
00004f  00                DCB      0x00
                  flag
000050  04                DCB      0x04
                  second_flag
000051  00                DCB      0x00
                  LOCK_ON_flag
000052  01                DCB      0x01
                  LOCK_OFF_flag
000053  01                DCB      0x01

                  __ARM_use_no_argv EQU 0

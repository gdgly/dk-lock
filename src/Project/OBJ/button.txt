; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\button.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\button.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\driver -I..\BSP -I..\system -I..\tplib -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\app -I..\MQTT -IE:\github\dk-lock\src\Project\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=.\obj\button.crf ..\driver\button.c]
                          THUMB

                          AREA ||i.button_get_state||, CODE, READONLY, ALIGN=2

                  button_get_state PROC
;;;68     
;;;69     button_state_e button_get_state(u8 button_name, u32 long_time)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;71     	
;;;72     	u8 i = 0;
000008  2600              MOVS     r6,#0
;;;73     	u8 button_cnt = 0;
00000a  2700              MOVS     r7,#0
;;;74     	u8 button_state = 0;
00000c  46b0              MOV      r8,r6
;;;75     	
;;;76     	
;;;77     	for(i=0; i<BUTTON_VALID_CNT; i++)
00000e  bf00              NOP      
000010  e00a              B        |L1.40|
                  |L1.18|
;;;78     	{
;;;79     		if(BUTTON1_READ() == 0)
000012  2140              MOVS     r1,#0x40
000014  482d              LDR      r0,|L1.204|
000016  f7fffffe          BL       GPIO_ReadInputDataBit
00001a  b910              CBNZ     r0,|L1.34|
;;;80     		{
;;;81     			button_cnt++;
00001c  1c78              ADDS     r0,r7,#1
00001e  b2c7              UXTB     r7,r0
000020  e000              B        |L1.36|
                  |L1.34|
;;;82     		}
;;;83     		else
;;;84     		{
;;;85     			break;
000022  e003              B        |L1.44|
                  |L1.36|
000024  1c70              ADDS     r0,r6,#1              ;77
000026  b2c6              UXTB     r6,r0                 ;77
                  |L1.40|
000028  2e0a              CMP      r6,#0xa               ;77
00002a  dbf2              BLT      |L1.18|
                  |L1.44|
00002c  bf00              NOP      
;;;86     		}
;;;87     	}
;;;88     	
;;;89     	if(button_cnt >= BUTTON_VALID_CNT)
00002e  2f0a              CMP      r7,#0xa
000030  db02              BLT      |L1.56|
;;;90     	{
;;;91     		button_state = 0;
000032  f04f0800          MOV      r8,#0
000036  e001              B        |L1.60|
                  |L1.56|
;;;92     	}
;;;93     	else
;;;94     	{
;;;95     		button_state = 1;
000038  f04f0801          MOV      r8,#1
                  |L1.60|
;;;96     	}
;;;97     		
;;;98     	if(0 == button_state)
00003c  f1b80f00          CMP      r8,#0
000040  d114              BNE      |L1.108|
;;;99     	{
;;;100    		button_info[button_name].butt_en = ENABLE;
000042  2001              MOVS     r0,#1
000044  4922              LDR      r1,|L1.208|
000046  eb0101c4          ADD      r1,r1,r4,LSL #3
00004a  7048              STRB     r0,[r1,#1]
;;;101    		if(button_info[button_name].butt_cnt < 5)
00004c  4820              LDR      r0,|L1.208|
00004e  eb0000c4          ADD      r0,r0,r4,LSL #3
000052  7880              LDRB     r0,[r0,#2]
000054  2805              CMP      r0,#5
000056  da12              BGE      |L1.126|
;;;102    		{
;;;103    			button_info[button_name].butt_cnt++;
000058  481d              LDR      r0,|L1.208|
00005a  eb0000c4          ADD      r0,r0,r4,LSL #3
00005e  7880              LDRB     r0,[r0,#2]
000060  1c40              ADDS     r0,r0,#1
000062  491b              LDR      r1,|L1.208|
000064  eb0101c4          ADD      r1,r1,r4,LSL #3
000068  7088              STRB     r0,[r1,#2]
00006a  e008              B        |L1.126|
                  |L1.108|
;;;104    		}
;;;105    	}
;;;106    	else
;;;107    	{
;;;108    		button_info[button_name].butt_cnt = 0;
00006c  2000              MOVS     r0,#0
00006e  4918              LDR      r1,|L1.208|
000070  eb0101c4          ADD      r1,r1,r4,LSL #3
000074  7088              STRB     r0,[r1,#2]
;;;109    		button_info[button_name].butt_long_press_timer = long_time;
000076  4816              LDR      r0,|L1.208|
000078  eb0000c4          ADD      r0,r0,r4,LSL #3
00007c  6045              STR      r5,[r0,#4]
                  |L1.126|
;;;110    	}
;;;111    	
;;;112    	if(button_info[button_name].butt_cnt <= 0)
00007e  4814              LDR      r0,|L1.208|
000080  eb0000c4          ADD      r0,r0,r4,LSL #3
000084  7880              LDRB     r0,[r0,#2]
000086  2800              CMP      r0,#0
000088  dc04              BGT      |L1.148|
;;;113    	{
;;;114    		button_info[button_name].butt_state = button_up;
00008a  2001              MOVS     r0,#1
00008c  4910              LDR      r1,|L1.208|
00008e  f8010034          STRB     r0,[r1,r4,LSL #3]
000092  e016              B        |L1.194|
                  |L1.148|
;;;115    	}
;;;116    	else if(button_info[button_name].butt_cnt <= 5)
000094  480e              LDR      r0,|L1.208|
000096  eb0000c4          ADD      r0,r0,r4,LSL #3
00009a  7880              LDRB     r0,[r0,#2]
00009c  2805              CMP      r0,#5
00009e  dc10              BGT      |L1.194|
;;;117    	{
;;;118    		if(button_info[button_name].butt_state == button_up)
0000a0  480b              LDR      r0,|L1.208|
0000a2  f8100034          LDRB     r0,[r0,r4,LSL #3]
0000a6  2801              CMP      r0,#1
0000a8  d100              BNE      |L1.172|
;;;119    		{
;;;120    			button_info[button_name].butt_state == button_click;
0000aa  e00a              B        |L1.194|
                  |L1.172|
;;;121    		}
;;;122    		else if(button_click == button_info[button_name].butt_state)
0000ac  4808              LDR      r0,|L1.208|
0000ae  f8100034          LDRB     r0,[r0,r4,LSL #3]
0000b2  2802              CMP      r0,#2
0000b4  d105              BNE      |L1.194|
;;;123    		{
;;;124    			if(0 == button_info[button_name].butt_long_press_timer)
0000b6  4806              LDR      r0,|L1.208|
0000b8  eb0000c4          ADD      r0,r0,r4,LSL #3
0000bc  6840              LDR      r0,[r0,#4]
0000be  b900              CBNZ     r0,|L1.194|
;;;125    			{
;;;126    				button_info[button_name].butt_state == button_long_press;
0000c0  bf00              NOP      
                  |L1.194|
;;;127    			}
;;;128    		
;;;129    		}
;;;130    	}
;;;131    	
;;;132    	
;;;133    	return button_info[button_name].butt_state;
0000c2  4803              LDR      r0,|L1.208|
0000c4  f8100034          LDRB     r0,[r0,r4,LSL #3]
;;;134    }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;135    
                          ENDP

                  |L1.204|
                          DCD      0x40011000
                  |L1.208|
                          DCD      button_info

                          AREA ||i.button_get_value||, CODE, READONLY, ALIGN=2

                  button_get_value PROC
;;;23     
;;;24     u8 button_get_value(void)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {
;;;26     	u8 val = 0;
000002  2600              MOVS     r6,#0
;;;27     	u8 i = 0;
000004  2400              MOVS     r4,#0
;;;28     	u8 button_cnt = 0;
000006  2500              MOVS     r5,#0
;;;29     	
;;;30     	for(i=0; i<30; i++)
000008  bf00              NOP      
00000a  e00a              B        |L2.34|
                  |L2.12|
;;;31     	{
;;;32     		if(BUTTON1_READ() == 0)
00000c  2140              MOVS     r1,#0x40
00000e  4809              LDR      r0,|L2.52|
000010  f7fffffe          BL       GPIO_ReadInputDataBit
000014  b910              CBNZ     r0,|L2.28|
;;;33     		{
;;;34     			button_cnt++;
000016  1c68              ADDS     r0,r5,#1
000018  b2c5              UXTB     r5,r0
00001a  e000              B        |L2.30|
                  |L2.28|
;;;35     		}
;;;36     		else
;;;37     		{
;;;38     			button_cnt = 0;
00001c  2500              MOVS     r5,#0
                  |L2.30|
00001e  1c60              ADDS     r0,r4,#1              ;30
000020  b2c4              UXTB     r4,r0                 ;30
                  |L2.34|
000022  2c1e              CMP      r4,#0x1e              ;30
000024  dbf2              BLT      |L2.12|
;;;39     		}
;;;40     	}
;;;41     	
;;;42     	if(button_cnt >= 30)
000026  2d1e              CMP      r5,#0x1e
000028  db01              BLT      |L2.46|
;;;43     	{
;;;44     		return 0;
00002a  2000              MOVS     r0,#0
                  |L2.44|
;;;45     	}
;;;46     	else
;;;47     	{
;;;48     		return 1;
;;;49     	}
;;;50     }
00002c  bd70              POP      {r4-r6,pc}
                  |L2.46|
00002e  2001              MOVS     r0,#1                 ;48
000030  e7fc              B        |L2.44|
;;;51     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x40011000

                          AREA ||i.button_gpio_init||, CODE, READONLY, ALIGN=2

                  button_gpio_init PROC
;;;11     
;;;12     void button_gpio_init(void)
000000  b508              PUSH     {r3,lr}
;;;13     {
;;;14     	GPIO_InitTypeDef gpio_init_structure;
;;;15     	
;;;16     	//button
;;;17     	gpio_init_structure.GPIO_Pin = GPIO_Pin_6;
000002  2040              MOVS     r0,#0x40
000004  f8ad0000          STRH     r0,[sp,#0]
;;;18       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;
000008  2003              MOVS     r0,#3
00000a  f88d0002          STRB     r0,[sp,#2]
;;;19     	gpio_init_structure.GPIO_Mode = GPIO_Mode_IPU;          
00000e  2048              MOVS     r0,#0x48
000010  f88d0003          STRB     r0,[sp,#3]
;;;20       	GPIO_Init(GPIOC, &gpio_init_structure);
000014  4669              MOV      r1,sp
000016  4802              LDR      r0,|L3.32|
000018  f7fffffe          BL       GPIO_Init
;;;21     }
00001c  bd08              POP      {r3,pc}
;;;22     
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40011000

                          AREA ||i.button_timer_ms||, CODE, READONLY, ALIGN=2

                  button_timer_ms PROC
;;;53     
;;;54     void button_timer_ms(void)
000000  2000              MOVS     r0,#0
;;;55     {
;;;56     	u8 i = 0;
;;;57     	
;;;58     	for(i=0; i<BUTTON_SUM; i++)
000002  bf00              NOP      
000004  e010              B        |L4.40|
                  |L4.6|
;;;59     	{
;;;60     		if(button_info[i].butt_en == ENABLE)
000006  490a              LDR      r1,|L4.48|
000008  eb0101c0          ADD      r1,r1,r0,LSL #3
00000c  7849              LDRB     r1,[r1,#1]
00000e  2901              CMP      r1,#1
000010  d108              BNE      |L4.36|
;;;61     		{
;;;62     			button_info[i].butt_long_press_timer--;
000012  4907              LDR      r1,|L4.48|
000014  eb0101c0          ADD      r1,r1,r0,LSL #3
000018  6849              LDR      r1,[r1,#4]
00001a  1e49              SUBS     r1,r1,#1
00001c  4a04              LDR      r2,|L4.48|
00001e  eb0202c0          ADD      r2,r2,r0,LSL #3
000022  6051              STR      r1,[r2,#4]
                  |L4.36|
000024  1c41              ADDS     r1,r0,#1              ;58
000026  b2c8              UXTB     r0,r1                 ;58
                  |L4.40|
000028  2801              CMP      r0,#1                 ;58
00002a  dbec              BLT      |L4.6|
;;;63     		}
;;;64     	}
;;;65     }
00002c  4770              BX       lr
;;;66     
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      button_info

                          AREA ||.data||, DATA, ALIGN=2

                  button_info
                          %        8

; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\driver -I..\BSP -I..\system -I..\tplib -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\app -I..\MQTT -IE:\github\dk-lock\src\Project\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=.\obj\main.crf ..\app\main.c]
                          THUMB

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;147    
;;;148    int main(void)
000000  b508              PUSH     {r3,lr}
;;;149    { 
;;;150    	u16 j,i,rxlen;
;;;151    	u16 k = 0x1A;
000002  bf00              NOP      
;;;152    	u8 upload=0; 
000004  bf00              NOP      
;;;153    	u8 *ret;
;;;154    	uint8_t status = 0;
000006  bf00              NOP      
;;;155    //	u8 tt = 0;
;;;156    	static u8 mqtt_flag = 0;
;;;157    //	u8 buf 
;;;158    	u8 end_char[1];
;;;159    	int mqtt_pub = 0;
000008  bf00              NOP      
;;;160    	int mqtt_con = 0;
00000a  bf00              NOP      
;;;161    	
;;;162    	end_char[0] = 0x1A;//结束字符
00000c  201a              MOVS     r0,#0x1a
00000e  9000              STR      r0,[sp,#0]
;;;163    
;;;164    	
;;;165    	bsp_init();
000010  f7fffffe          BL       bsp_init
;;;166    	
;;;167                             
;;;168    	USART_OUT(USART1, "uart1 is ok\r\n");
<<<<<<< HEAD
000014  a114              ADR      r1,|L1.104|
000016  4818              LDR      r0,|L1.120|
000018  f7fffffe          BL       USART_OUT
;;;169    
;;;170    	USART_OUT(UART4, "uart4 is ok\r\n");
00001c  a117              ADR      r1,|L1.124|
00001e  481b              LDR      r0,|L1.140|
000020  f7fffffe          BL       USART_OUT
;;;171    	while(1)
000024  e01f              B        |L1.102|
                  |L1.38|
;;;172    	{
;;;173    	
;;;174    //		if(mqtt_flag == 0)
;;;175    //		{
;;;176    //			gprs_init_task();
;;;177    //			timer_delay_1ms(1500);
;;;178    //			mqtt_con = mqtt_connect();
;;;179    //			if(1 == mqtt_con)
;;;180    //			{
;;;181    //				mqtt_flag = 1;
;;;182    //				timer_delay_1ms(20);
;;;183    //				USART_OUT(USART1, "mqtt_connect ok\r\n");
;;;184    //			}
;;;185    //		}
;;;186    		
;;;187    	
;;;188    		usart1_recv_data();
000026  f7fffffe          BL       usart1_recv_data
;;;189    		usart2_recv_data();
00002a  f7fffffe          BL       usart2_recv_data
;;;190    //		usart4_recv_data();
;;;191    
;;;192    		
;;;193    		
;;;194    		
;;;195    		
;;;196    	
;;;197    //		if(timer_is_timeout_1ms(timer_keep_alive, 1000*20) == 0)
;;;198    		{
;;;199    			mqtt_keep_alive();
00002e  f7fffffe          BL       mqtt_keep_alive
;;;200    		}
;;;201    
;;;202    //			timer_delay_1ms(5000);
;;;203    
;;;204    
;;;205    		
;;;206    		
;;;207    		p1 = strstr((char*)mqtt_buff->pdata, "CLOSE");
000032  a117              ADR      r1,|L1.144|
000034  4818              LDR      r0,|L1.152|
000036  6800              LDR      r0,[r0,#0]  ; mqtt_buff
000038  1c80              ADDS     r0,r0,#2
00003a  f7fffffe          BL       strstr
00003e  4917              LDR      r1,|L1.156|
000040  6008              STR      r0,[r1,#0]  ; p1
;;;208    		if(p1 !=NULL)
000042  4608              MOV      r0,r1
000044  6800              LDR      r0,[r0,#0]  ; p1
000046  b170              CBZ      r0,|L1.102|
;;;209    		{
;;;210    			memset(mqtt_buff, 0, sizeof(usart_buff_t));	
000048  f2402102          MOV      r1,#0x202
00004c  4812              LDR      r0,|L1.152|
00004e  6800              LDR      r0,[r0,#0]  ; mqtt_buff
000050  f7fffffe          BL       __aeabi_memclr
;;;211    			mqtt_flag = 0;
000054  2000              MOVS     r0,#0
000056  4912              LDR      r1,|L1.160|
000058  7008              STRB     r0,[r1,#0]
;;;212    			gprs_status = 0;
00005a  4912              LDR      r1,|L1.164|
00005c  7008              STRB     r0,[r1,#0]
;;;213    			USART_OUT(USART1, "MQTT SERVER CLOSE\r\n");
00005e  a112              ADR      r1,|L1.168|
000060  4805              LDR      r0,|L1.120|
000062  f7fffffe          BL       USART_OUT
                  |L1.102|
000066  e7de              B        |L1.38|
;;;214    		}
;;;215    	}
;;;216    	
;;;217    	
;;;218    	
;;;219    	
;;;220    	while(1)
;;;221    	{	 
;;;222    
;;;223    		while(1)
;;;224    		{
;;;225    			gprs_config();
;;;226    			if(gprs_status == 255)
;;;227    			{
;;;228    				MakeFile_MD5_Checksum(PARK_LOCK_Buffer, 16);			
;;;229    				break;
;;;230    			}
;;;231    		}
;;;232    	
;;;233    		
;;;234    		usart1_recv_data();
;;;235    		usart2_recv_data();
;;;236    	
;;;237    		// 电池信息
;;;238    		Bat_V =Get_Adc_Average(ADC_Channel_0,10);
;;;239    		Bat_V=Bat_V*3300/4096;
;;;240    		Bat_V=Bat_V*88/20;
;;;241    		Bat_Pre=(Bat_V-5000)*100/2400;
;;;242    		
;;;243    //		if(Bat_Pre<20&&Bat_Pre>10&&Bat_Pre_Flag==0)
;;;244    		if(timer_is_timeout_1ms(timer_batt, 1000*60*60) == 0)
;;;245    		{	
;;;246    			Bat_Pre_Flag =  1;
;;;247    			memset(send_buff, 0, 100);	
;;;248    			sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",24,2\r\n");
;;;249    
;;;250    			USART_OUT(USART1, "ccc=%s\r\n", send_buff);
;;;251    
;;;252    			ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;253    			if(ret != NULL)
;;;254    			{
;;;255    				memset(expressText, 0 ,512);
;;;256    				memset(cipherText, 0 ,512);
;;;257    				sprintf((char *)expressText, "{%c%s%c:%s}",'"',"battery",'"',"20");
;;;258    				USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;259    				AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;260    				
;;;261    				USART_OUT(USART1, "aesKey=%s\r\n", aesKey);
;;;262    				USART_OUT(USART1, "cipherText=%s\r\n", cipherText);
;;;263    				ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;264    				if(ret != NULL)
;;;265    				{
;;;266    					timer_is_timeout_1ms(timer_heartbeat, 0);
;;;267    				}			
;;;268    			}
;;;269    			else
;;;270    			{
;;;271    			}
;;;272    
;;;273    		}
;;;274    //		//接收锁数据
;;;275    		p1 = strstr((u8*)protocol_buff, "topic: lock/");
;;;276    		p2 = strstr((u8 *)p1,(u8 *)PARK_LOCK_Buffer);
;;;277    		if(strncmp((char *)p1,(char *)"topic: lock/",12)==0)
;;;278    		{
;;;279    			
;;;280    			if(LOCK_ON_READ()==0 || LOCK_OFF_READ()==0)
;;;281    			{
;;;282    			timer_is_timeout_1ms(timer_heartbeat, 0);
;;;283    			USART_OUT(USART1, "lock data\r\n");
;;;284    			memset(receiveText ,0 , 512);
;;;285    			memset(expressText ,0 , 512);
;;;286    			
;;;287    			strcpy((char*)receiveText ,(char *)(p1+33));
;;;288    			USART_OUT(USART1, "receiveText=%s\r\n", receiveText);
;;;289    			AES_Decrypt(expressText, receiveText, aesKey);
;;;290    			if(*expressText==0x31)
;;;291    			{
;;;292    //				if(LOCK_ON_READ() == 0)
;;;293    //				if(lock_on_status_get() == 0)
;;;294    				if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1)
;;;295    				{
;;;296    					timer_is_timeout_1ms(timer_open_lock, 0);
;;;297    					Shaking=1;
;;;298    					Lock_Open=1;
;;;299    					USART_OUT(USART1, "Lock_Open11111\r\n");
;;;300    				}
;;;301    				else
;;;302    				{
;;;303    					Lock_Open=0;
;;;304    				}
;;;305    			}
;;;306    			else if(*expressText==0x32)
;;;307    			{
;;;308    //				if(LOCK_OFF_READ() == 0)
;;;309    //				if(lock_off_status_get() == 0)
;;;310    				if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0)	
;;;311    				{
;;;312    					timer_is_timeout_1ms(timer_close_lock, 0);
;;;313    					Shaking=1;
;;;314    					Lock_Close=1;
;;;315    					USART_OUT(USART1, "Lock_Close11111\r\n");
;;;316    				}
;;;317    				else
;;;318    				{
;;;319    					Lock_Close=0;
;;;320    				}
;;;321    			
;;;322    			}
;;;323    			else if(*expressText == 0x30)
;;;324    			{
;;;325    				lock_stop();	//停止运行;
;;;326    			}
;;;327    			
;;;328    			memset(protocol_buff, 0, 512);					
;;;329    		}
;;;330    	}
;;;331    
;;;332    		//开锁逻辑		
;;;333    		if(Lock_Open == 1)
;;;334    		{
;;;335    
;;;336    			if(timer_is_timeout_1ms(timer_open_lock, 4000) == 0)
;;;337    			{
;;;338    				lock_open_err_flag = 1;
;;;339    				
;;;340    				lock_close();
;;;341    				USART_OUT(USART1, "Lock_Open timer\r\n");
;;;342    			}
;;;343    			USART_OUT(USART1, "Lock_Open\r\n");
;;;344    			if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1)
;;;345    			{
;;;346    				lock_open();	//开锁	
;;;347    				USART_OUT(USART1, "AAA lock_open\r\n");
;;;348    			}
;;;349    //			if(LOCK_OFF_READ()==0) //正常开锁
;;;350    			if(lock_off_status_get() == 0)
;;;351    			{
;;;352    				USART_OUT(USART1, "AAA lock_stop\r\n");
;;;353    				
;;;354    				Lock_Open = 0;
;;;355    				lock_stop();	//停止运行
;;;356    				Shaking = 0;
;;;357    				
;;;358    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;359    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;360    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;361    				if(ret != NULL)
;;;362    				{
;;;363    					memset(expressText, 0 ,512);
;;;364    					memset(cipherText, 0 ,512);
;;;365    					sprintf(expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"0");
;;;366    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;367    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;368    					USART_OUT(USART1, "cipherText=%s\r\n", cipherText);
;;;369    					
;;;370    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;371    					if(ret != NULL)
;;;372    					{
;;;373    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;374    					}
;;;375    				}			
;;;376    			}
;;;377    			
;;;378    			if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1 && lock_open_err_flag == 1)//开锁超时异常处理
;;;379    			{
;;;380    				lock_open_err_flag = 0;
;;;381    				Lock_Open = 0;
;;;382    				lock_stop();
;;;383    				Shaking = 0;
;;;384    				USART_OUT(USART1, "open lock unusual\r\n");
;;;385    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;386    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;387    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;388    				if(ret != NULL)
;;;389    				{
;;;390    					memset(expressText, 0 ,512);
;;;391    					memset(cipherText, 0 ,512);
;;;392    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"1");
;;;393    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;394    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;395    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;396    					if(ret != NULL)
;;;397    					{
;;;398    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;399    					}
;;;400    				}
;;;401    				else
;;;402    				{
;;;403    
;;;404    				}	
;;;405    			}
;;;406    		}
;;;407    		//关锁逻辑
;;;408    		if(Lock_Close == 1)
;;;409    		{
;;;410    			if(timer_is_timeout_1ms(timer_close_lock, 4000) == 0)
;;;411    			{
;;;412    				lock_open();
;;;413    				lock_close_err_flag = 1;
;;;414    				USART_OUT(USART1, "Lock_Close timer\r\n");
;;;415    			}
;;;416    			USART_OUT(USART1, "lock close\r\n");
;;;417    			if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0)	//正常关锁
;;;418    			{
;;;419    				lock_close();
;;;420    				USART_OUT(USART1, "BBB lock close\r\n");
;;;421    			}
;;;422    			
;;;423    //			if(LOCK_ON_READ() == 0)	//正常关锁
;;;424    			if(lock_on_status_get() == 0)
;;;425    			{
;;;426    				Lock_Close = 0;
;;;427    				lock_stop();	//停止运行
;;;428    				Shaking = 0;
;;;429    				USART_OUT(USART1, "BBB lock_stop\r\n");
;;;430    				
;;;431    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;432    				USART_OUT(USART1, "PublishLockBackbuf=%s\r\n", send_buff);
;;;433    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;434    				if(ret != NULL)
;;;435    				{
;;;436    					memset(expressText, 0 ,512);
;;;437    					memset(cipherText, 0 ,512);
;;;438    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"0");
;;;439    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;440    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;441    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;442    					if(ret != NULL)
;;;443    					{
;;;444    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;445    					}
;;;446    				}
;;;447    			}
;;;448    			
;;;449    			if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0 && lock_close_err_flag == 1) //关锁超时处理
;;;450    			{
;;;451    				lock_close_err_flag = 0;
;;;452    				Lock_Close = 0;
;;;453    				lock_stop();	//停止运行
;;;454    				Shaking = 0;
;;;455    				USART_OUT(USART1, "close lock unusual\r\n");
;;;456    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;457    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;458    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;459    				if(ret != NULL)
;;;460    				{
;;;461    					memset(expressText, 0 ,512);
;;;462    					memset(cipherText, 0 ,512);
;;;463    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"1");
;;;464    					AES_Encrypt((char *)expressText, (char*)cipherText, (char*)aesKey);
;;;465    				
;;;466    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;467    					if(ret != NULL)
;;;468    					{
;;;469    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;470    					}
;;;471    				}
;;;472    			}		
;;;473    		}
;;;474    		//按键
;;;475    		if(button_get_value() == 0)
;;;476    		{
;;;477    			USART_OUT(USART1, "button_get_value\r\n");
;;;478    			timer_is_timeout_1ms(timer_close_lock, 0);
;;;479    			Lock_Close = 1;
;;;480    			Shaking=1;	
;;;481    		}
;;;482    			
;;;483    		
;;;484    		//报警器
;;;485    		p1 = strstr((char*)protocol_buff, "topic: bell/");
;;;486    		p2 = strstr((char *)p1,(char *)PARK_LOCK_Buffer);
;;;487    		if(strncmp((char *)p1,(char *)"topic: bell/",12)==0 && bell_flag==0)
;;;488    		{
;;;489    			timer_is_timeout_1ms(timer_heartbeat, 0);
;;;490    			USART_OUT(USART1, "bell\r\n");
;;;491    			memset(protocol_buff, 0, 512);	
;;;492    			bell_flag=1;
;;;493      	
;;;494    			BEEP_ON();
;;;495    			timer_delay_1ms(100);
;;;496    			BEEP_OFF();
;;;497    		}
;;;498    				
;;;499    		if(bell_flag == 1)
;;;500    		{
;;;501    			bell_flag = 0;
;;;502    		}
;;;503    		//晃动报警
;;;504    		if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==1 && Shaking==0)
;;;505    		{
;;;506    			USART_OUT(USART1, "Sharking\r\n");
;;;507    			if(timer_is_timeout_1ms(timer_bell_1, 400) == 0)
;;;508    			{
;;;509    				BEEP_ON();
;;;510    			}
;;;511    			if(timer_is_timeout_1ms(timer_bell_2, 800) == 0)
;;;512    			{
;;;513    				BEEP_OFF();
;;;514    			}
;;;515    		}
;;;516    		else
;;;517    		{
;;;518    			BEEP_OFF();
;;;519    		}
;;;520    		
;;;521    		//断线重连
;;;522    		p1 = strstr((char*)protocol_buff, "MQTT CLOSE");
;;;523    		if(p1 !=NULL)
;;;524    		{
;;;525    			memset(protocol_buff, 0, 512);	
;;;526    			gprs_status = 0;
;;;527    			USART_OUT(USART1, "MQTT SERVER CLOSE\r\n");
;;;528    		}
;;;529    		
;;;530    
;;;531    		//心跳
;;;532    		if(timer_is_timeout_1ms(timer_heartbeat, 1000*60*10) == 0)
;;;533    		{
;;;534    			memset(send_buff, 0, 100);
;;;535    			sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",1,2\r\n");
;;;536    	
;;;537    			USART_OUT(USART1, "heartbeat=%s\r\n", send_buff);
;;;538    			ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;539    			if(ret != NULL)
;;;540    			{
;;;541    				memset(heartbeat_buff, 0, 2);
;;;542    				heartbeat_buff[0] = 0x30;
;;;543    				ret = gprs_send_at(heartbeat_buff, "OK", 300, 0);
;;;544    				if(ret != NULL)
;;;545    				{
;;;546    					
;;;547    				}	
;;;548    			}
;;;549    			else
;;;550    			{
;;;551    				
;;;552    			}
;;;553    		}	
;;;554    		
;;;555    		
;;;556    //		if(timer_is_timeout_1ms(timer_gps_cycle, 1000*60*60*24) == 0)
;;;557    //		{
;;;558    //			gps_flag = 1;
;;;559    //		}
;;;560    		
;;;561    		
;;;562    
;;;563    	}	 
;;;564    }
;;;565     
                          ENDP

                  |L1.104|
000068  75617274          DCB      "uart1 is ok\r\n",0
00006c  31206973
000070  206f6b0d
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0
                  |L1.120|
                          DCD      0x40013800
                  |L1.124|
00007c  75617274          DCB      "uart4 is ok\r\n",0
000080  34206973
000084  206f6b0d
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L1.140|
                          DCD      0x40004c00
                  |L1.144|
000090  434c4f53          DCB      "CLOSE",0
000094  4500    
000096  00                DCB      0
000097  00                DCB      0
                  |L1.152|
                          DCD      mqtt_buff
                  |L1.156|
                          DCD      ||p1||
                  |L1.160|
                          DCD      mqtt_flag
                  |L1.164|
                          DCD      gprs_status
                  |L1.168|
0000a8  4d515454          DCB      "MQTT SERVER CLOSE\r\n",0
0000ac  20534552
0000b0  56455220
0000b4  434c4f53
0000b8  450d0a00
=======
000014  a11c              ADR      r1,|L1.136|
000016  4820              LDR      r0,|L1.152|
000018  f7fffffe          BL       USART_OUT
;;;169    
;;;170    	
;;;171    //	mqtt_keep_alive();
;;;172    //	
;;;173    //	mqtt_qos0();
;;;174    	
;;;175    	while(1)
00001c  e032              B        |L1.132|
                  |L1.30|
;;;176    	{
;;;177    	
;;;178    		if(mqtt_flag == 0)
00001e  481f              LDR      r0,|L1.156|
000020  7800              LDRB     r0,[r0,#0]  ; mqtt_flag
000022  b998              CBNZ     r0,|L1.76|
;;;179    		{
;;;180    			gprs_init_task();
000024  f7fffffe          BL       gprs_init_task
;;;181    			timer_delay_1ms(1500);
000028  f24050dc          MOV      r0,#0x5dc
00002c  f7fffffe          BL       timer_delay_1ms
;;;182    			mqtt_con = mqtt_connect();
000030  f7fffffe          BL       mqtt_connect
000034  4604              MOV      r4,r0
;;;183    			if(1 == mqtt_con)
000036  2c01              CMP      r4,#1
000038  d108              BNE      |L1.76|
;;;184    			{
;;;185    				mqtt_flag = 1;
00003a  4918              LDR      r1,|L1.156|
00003c  7008              STRB     r0,[r1,#0]
;;;186    				timer_delay_1ms(20);
00003e  2014              MOVS     r0,#0x14
000040  f7fffffe          BL       timer_delay_1ms
;;;187    				USART_OUT(USART1, "mqtt_connect ok\r\n");
000044  a116              ADR      r1,|L1.160|
000046  4814              LDR      r0,|L1.152|
000048  f7fffffe          BL       USART_OUT
                  |L1.76|
;;;188    			}
;;;189    		}
;;;190    		
;;;191    		usart2_recv_data();
00004c  f7fffffe          BL       usart2_recv_data
;;;192    		usart1_recv_data();
000050  f7fffffe          BL       usart1_recv_data
;;;193    		
;;;194    
;;;195    		p1 = strstr((char*)mqtt_buff->pdata, "CLOSE");
000054  a117              ADR      r1,|L1.180|
000056  4819              LDR      r0,|L1.188|
000058  6800              LDR      r0,[r0,#0]  ; mqtt_buff
00005a  1c80              ADDS     r0,r0,#2
00005c  f7fffffe          BL       strstr
000060  4917              LDR      r1,|L1.192|
000062  6008              STR      r0,[r1,#0]  ; p1
;;;196    		if(p1 !=NULL)
000064  4608              MOV      r0,r1
000066  6800              LDR      r0,[r0,#0]  ; p1
000068  b160              CBZ      r0,|L1.132|
;;;197    		{
;;;198    			memset(mqtt_buff, 0, sizeof(usart_buff_t));	
00006a  f2402102          MOV      r1,#0x202
00006e  4813              LDR      r0,|L1.188|
000070  6800              LDR      r0,[r0,#0]  ; mqtt_buff
000072  f7fffffe          BL       __aeabi_memclr
;;;199    			mqtt_flag = 0;
000076  2000              MOVS     r0,#0
000078  4908              LDR      r1,|L1.156|
00007a  7008              STRB     r0,[r1,#0]
;;;200    			USART_OUT(USART1, "MQTT SERVER CLOSE\r\n");
00007c  a111              ADR      r1,|L1.196|
00007e  4806              LDR      r0,|L1.152|
000080  f7fffffe          BL       USART_OUT
                  |L1.132|
000084  e7cb              B        |L1.30|
;;;201    		}
;;;202    //		if(timer_is_timeout_1ms(timer_keep_alive, 1000*30) == 0)
;;;203    //		{
;;;204    //			mqtt_keep_alive();
;;;205    //		}
;;;206    
;;;207    //			timer_delay_1ms(5000);
;;;208    //		}
;;;209    
;;;210    	}
;;;211    	
;;;212    	
;;;213    	
;;;214    	
;;;215    	while(1)
;;;216    	{	 
;;;217    
;;;218    		while(1)
;;;219    		{
;;;220    			gprs_config();
;;;221    			if(gprs_status == 255)
;;;222    			{
;;;223    				MakeFile_MD5_Checksum(PARK_LOCK_Buffer, 16);			
;;;224    				break;
;;;225    			}
;;;226    		}
;;;227    	
;;;228    		
;;;229    		usart1_recv_data();
;;;230    		usart2_recv_data();
;;;231    	
;;;232    		// 电池信息
;;;233    		Bat_V =Get_Adc_Average(ADC_Channel_0,10);
;;;234    		Bat_V=Bat_V*3300/4096;
;;;235    		Bat_V=Bat_V*88/20;
;;;236    		Bat_Pre=(Bat_V-5000)*100/2400;
;;;237    		
;;;238    //		if(Bat_Pre<20&&Bat_Pre>10&&Bat_Pre_Flag==0)
;;;239    		if(timer_is_timeout_1ms(timer_batt, 1000*60*60) == 0)
;;;240    		{	
;;;241    			Bat_Pre_Flag =  1;
;;;242    			memset(send_buff, 0, 100);	
;;;243    			sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",24,2\r\n");
;;;244    
;;;245    			USART_OUT(USART1, "ccc=%s\r\n", send_buff);
;;;246    
;;;247    			ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;248    			if(ret != NULL)
;;;249    			{
;;;250    				memset(expressText, 0 ,512);
;;;251    				memset(cipherText, 0 ,512);
;;;252    				sprintf((char *)expressText, "{%c%s%c:%s}",'"',"battery",'"',"20");
;;;253    				USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;254    				AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;255    				
;;;256    				USART_OUT(USART1, "aesKey=%s\r\n", aesKey);
;;;257    				USART_OUT(USART1, "cipherText=%s\r\n", cipherText);
;;;258    				ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;259    				if(ret != NULL)
;;;260    				{
;;;261    					timer_is_timeout_1ms(timer_heartbeat, 0);
;;;262    				}			
;;;263    			}
;;;264    			else
;;;265    			{
;;;266    			}
;;;267    
;;;268    		}
;;;269    //		//接收锁数据
;;;270    		p1 = strstr((u8*)protocol_buff, "topic: lock/");
;;;271    		p2 = strstr((u8 *)p1,(u8 *)PARK_LOCK_Buffer);
;;;272    		if(strncmp((char *)p1,(char *)"topic: lock/",12)==0)
;;;273    		{
;;;274    			
;;;275    			if(LOCK_ON_READ()==0 || LOCK_OFF_READ()==0)
;;;276    			{
;;;277    			timer_is_timeout_1ms(timer_heartbeat, 0);
;;;278    			USART_OUT(USART1, "lock data\r\n");
;;;279    			memset(receiveText ,0 , 512);
;;;280    			memset(expressText ,0 , 512);
;;;281    			
;;;282    			strcpy((char*)receiveText ,(char *)(p1+33));
;;;283    			USART_OUT(USART1, "receiveText=%s\r\n", receiveText);
;;;284    			AES_Decrypt(expressText, receiveText, aesKey);
;;;285    			if(*expressText==0x31)
;;;286    			{
;;;287    //				if(LOCK_ON_READ() == 0)
;;;288    //				if(lock_on_status_get() == 0)
;;;289    				if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1)
;;;290    				{
;;;291    					timer_is_timeout_1ms(timer_open_lock, 0);
;;;292    					Shaking=1;
;;;293    					Lock_Open=1;
;;;294    					USART_OUT(USART1, "Lock_Open11111\r\n");
;;;295    				}
;;;296    				else
;;;297    				{
;;;298    					Lock_Open=0;
;;;299    				}
;;;300    			}
;;;301    			else if(*expressText==0x32)
;;;302    			{
;;;303    //				if(LOCK_OFF_READ() == 0)
;;;304    //				if(lock_off_status_get() == 0)
;;;305    				if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0)	
;;;306    				{
;;;307    					timer_is_timeout_1ms(timer_close_lock, 0);
;;;308    					Shaking=1;
;;;309    					Lock_Close=1;
;;;310    					USART_OUT(USART1, "Lock_Close11111\r\n");
;;;311    				}
;;;312    				else
;;;313    				{
;;;314    					Lock_Close=0;
;;;315    				}
;;;316    			
;;;317    			}
;;;318    			else if(*expressText == 0x30)
;;;319    			{
;;;320    				lock_stop();	//停止运行;
;;;321    			}
;;;322    			
;;;323    			memset(protocol_buff, 0, 512);					
;;;324    		}
;;;325    	}
;;;326    
;;;327    		//开锁逻辑		
;;;328    		if(Lock_Open == 1)
;;;329    		{
;;;330    
;;;331    			if(timer_is_timeout_1ms(timer_open_lock, 4000) == 0)
;;;332    			{
;;;333    				lock_open_err_flag = 1;
;;;334    				
;;;335    				lock_close();
;;;336    				USART_OUT(USART1, "Lock_Open timer\r\n");
;;;337    			}
;;;338    			USART_OUT(USART1, "Lock_Open\r\n");
;;;339    			if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1)
;;;340    			{
;;;341    				lock_open();	//开锁	
;;;342    				USART_OUT(USART1, "AAA lock_open\r\n");
;;;343    			}
;;;344    //			if(LOCK_OFF_READ()==0) //正常开锁
;;;345    			if(lock_off_status_get() == 0)
;;;346    			{
;;;347    				USART_OUT(USART1, "AAA lock_stop\r\n");
;;;348    				
;;;349    				Lock_Open = 0;
;;;350    				lock_stop();	//停止运行
;;;351    				Shaking = 0;
;;;352    				
;;;353    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;354    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;355    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;356    				if(ret != NULL)
;;;357    				{
;;;358    					memset(expressText, 0 ,512);
;;;359    					memset(cipherText, 0 ,512);
;;;360    					sprintf(expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"0");
;;;361    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;362    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;363    					USART_OUT(USART1, "cipherText=%s\r\n", cipherText);
;;;364    					
;;;365    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;366    					if(ret != NULL)
;;;367    					{
;;;368    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;369    					}
;;;370    				}			
;;;371    			}
;;;372    			
;;;373    			if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1 && lock_open_err_flag == 1)//开锁超时异常处理
;;;374    			{
;;;375    				lock_open_err_flag = 0;
;;;376    				Lock_Open = 0;
;;;377    				lock_stop();
;;;378    				Shaking = 0;
;;;379    				USART_OUT(USART1, "open lock unusual\r\n");
;;;380    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;381    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;382    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;383    				if(ret != NULL)
;;;384    				{
;;;385    					memset(expressText, 0 ,512);
;;;386    					memset(cipherText, 0 ,512);
;;;387    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"1");
;;;388    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;389    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;390    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;391    					if(ret != NULL)
;;;392    					{
;;;393    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;394    					}
;;;395    				}
;;;396    				else
;;;397    				{
;;;398    
;;;399    				}	
;;;400    			}
;;;401    		}
;;;402    		//关锁逻辑
;;;403    		if(Lock_Close == 1)
;;;404    		{
;;;405    			if(timer_is_timeout_1ms(timer_close_lock, 4000) == 0)
;;;406    			{
;;;407    				lock_open();
;;;408    				lock_close_err_flag = 1;
;;;409    				USART_OUT(USART1, "Lock_Close timer\r\n");
;;;410    			}
;;;411    			USART_OUT(USART1, "lock close\r\n");
;;;412    			if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0)	//正常关锁
;;;413    			{
;;;414    				lock_close();
;;;415    				USART_OUT(USART1, "BBB lock close\r\n");
;;;416    			}
;;;417    			
;;;418    //			if(LOCK_ON_READ() == 0)	//正常关锁
;;;419    			if(lock_on_status_get() == 0)
;;;420    			{
;;;421    				Lock_Close = 0;
;;;422    				lock_stop();	//停止运行
;;;423    				Shaking = 0;
;;;424    				USART_OUT(USART1, "BBB lock_stop\r\n");
;;;425    				
;;;426    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;427    				USART_OUT(USART1, "PublishLockBackbuf=%s\r\n", send_buff);
;;;428    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;429    				if(ret != NULL)
;;;430    				{
;;;431    					memset(expressText, 0 ,512);
;;;432    					memset(cipherText, 0 ,512);
;;;433    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"0");
;;;434    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;435    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;436    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;437    					if(ret != NULL)
;;;438    					{
;;;439    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;440    					}
;;;441    				}
;;;442    			}
;;;443    			
;;;444    			if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0 && lock_close_err_flag == 1) //关锁超时处理
;;;445    			{
;;;446    				lock_close_err_flag = 0;
;;;447    				Lock_Close = 0;
;;;448    				lock_stop();	//停止运行
;;;449    				Shaking = 0;
;;;450    				USART_OUT(USART1, "close lock unusual\r\n");
;;;451    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;452    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;453    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;454    				if(ret != NULL)
;;;455    				{
;;;456    					memset(expressText, 0 ,512);
;;;457    					memset(cipherText, 0 ,512);
;;;458    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"1");
;;;459    					AES_Encrypt((char *)expressText, (char*)cipherText, (char*)aesKey);
;;;460    				
;;;461    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;462    					if(ret != NULL)
;;;463    					{
;;;464    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;465    					}
;;;466    				}
;;;467    			}		
;;;468    		}
;;;469    		//按键
;;;470    		if(button_get_value() == 0)
;;;471    		{
;;;472    			USART_OUT(USART1, "button_get_value\r\n");
;;;473    			timer_is_timeout_1ms(timer_close_lock, 0);
;;;474    			Lock_Close = 1;
;;;475    			Shaking=1;	
;;;476    		}
;;;477    			
;;;478    		
;;;479    		//报警器
;;;480    		p1 = strstr((char*)protocol_buff, "topic: bell/");
;;;481    		p2 = strstr((char *)p1,(char *)PARK_LOCK_Buffer);
;;;482    		if(strncmp((char *)p1,(char *)"topic: bell/",12)==0 && bell_flag==0)
;;;483    		{
;;;484    			timer_is_timeout_1ms(timer_heartbeat, 0);
;;;485    			USART_OUT(USART1, "bell\r\n");
;;;486    			memset(protocol_buff, 0, 512);	
;;;487    			bell_flag=1;
;;;488      	
;;;489    			BEEP_ON();
;;;490    			timer_delay_1ms(100);
;;;491    			BEEP_OFF();
;;;492    		}
;;;493    				
;;;494    		if(bell_flag == 1)
;;;495    		{
;;;496    			bell_flag = 0;
;;;497    		}
;;;498    		//晃动报警
;;;499    		if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==1 && Shaking==0)
;;;500    		{
;;;501    			USART_OUT(USART1, "Sharking\r\n");
;;;502    			if(timer_is_timeout_1ms(timer_bell_1, 400) == 0)
;;;503    			{
;;;504    				BEEP_ON();
;;;505    			}
;;;506    			if(timer_is_timeout_1ms(timer_bell_2, 800) == 0)
;;;507    			{
;;;508    				BEEP_OFF();
;;;509    			}
;;;510    		}
;;;511    		else
;;;512    		{
;;;513    			BEEP_OFF();
;;;514    		}
;;;515    		
;;;516    		//断线重连
;;;517    		p1 = strstr((char*)protocol_buff, "MQTT CLOSE");
;;;518    		if(p1 !=NULL)
;;;519    		{
;;;520    			memset(protocol_buff, 0, 512);	
;;;521    			gprs_status = 0;
;;;522    			USART_OUT(USART1, "MQTT SERVER CLOSE\r\n");
;;;523    		}
;;;524    		
;;;525    
;;;526    		//心跳
;;;527    		if(timer_is_timeout_1ms(timer_heartbeat, 1000*60*10) == 0)
;;;528    		{
;;;529    			memset(send_buff, 0, 100);
;;;530    			sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",1,2\r\n");
;;;531    	
;;;532    			USART_OUT(USART1, "heartbeat=%s\r\n", send_buff);
;;;533    			ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;534    			if(ret != NULL)
;;;535    			{
;;;536    				memset(heartbeat_buff, 0, 2);
;;;537    				heartbeat_buff[0] = 0x30;
;;;538    				ret = gprs_send_at(heartbeat_buff, "OK", 300, 0);
;;;539    				if(ret != NULL)
;;;540    				{
;;;541    					
;;;542    				}	
;;;543    			}
;;;544    			else
;;;545    			{
;;;546    				
;;;547    			}
;;;548    		}	
;;;549    		
;;;550    		
;;;551    //		if(timer_is_timeout_1ms(timer_gps_cycle, 1000*60*60*24) == 0)
;;;552    //		{
;;;553    //			gps_flag = 1;
;;;554    //		}
;;;555    		
;;;556    		
;;;557    
;;;558    	}	 
;;;559    }
;;;560     
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
000088  75617274          DCB      "uart1 is ok\r\n",0
00008c  31206973
000090  206f6b0d
000094  0a00    
000096  00                DCB      0
000097  00                DCB      0
                  |L1.152|
                          DCD      0x40013800
                  |L1.156|
                          DCD      mqtt_flag
                  |L1.160|
0000a0  6d717474          DCB      "mqtt_connect ok\r\n",0
0000a4  5f636f6e
0000a8  6e656374
0000ac  206f6b0d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L1.180|
0000b4  434c4f53          DCB      "CLOSE",0
0000b8  4500    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L1.188|
                          DCD      mqtt_buff
                  |L1.192|
                          DCD      ||p1||
                  |L1.196|
0000c4  4d515454          DCB      "MQTT SERVER CLOSE\r\n",0
0000c8  20534552
0000cc  56455220
0000d0  434c4f53
0000d4  450d0a00
>>>>>>> parent of 8334634... c

                          AREA ||i.test_encrypt_ecb||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  test_encrypt_ecb PROC
;;;107    
;;;108    static void test_encrypt_ecb(void)
000000  b500              PUSH     {lr}
;;;109    {
000002  b0bf              SUB      sp,sp,#0xfc
;;;110    
;;;111        uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
000004  a022              ADR      r0,|L2.144|
000006  e890000e          LDM      r0,{r1-r3}
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  e9cd233c          STRD     r2,r3,[sp,#0xf0]
000010  913b              STR      r1,[sp,#0xec]
000012  903e              STR      r0,[sp,#0xf8]
;;;112        uint8_t out[] = { 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97 };
000014  a322              ADR      r3,|L2.160|
000016  e9d31200          LDRD     r1,r2,[r3,#0]
00001a  e9d30302          LDRD     r0,r3,[r3,#8]
00001e  e9cd0339          STRD     r0,r3,[sp,#0xe4]
000022  e9cd1237          STRD     r1,r2,[sp,#0xdc]
;;;113    
;;;114    
;;;115        uint8_t in[]  = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a };
000026  a322              ADR      r3,|L2.176|
000028  e9d32000          LDRD     r2,r0,[r3,#0]
00002c  e9d31302          LDRD     r1,r3,[r3,#8]
000030  e9cd1335          STRD     r1,r3,[sp,#0xd4]
000034  e9cd2033          STRD     r2,r0,[sp,#0xcc]
;;;116       	struct AES_ctx ctx;
;;;117    	
;;;118    	
;;;119    	sprintf((char *)expressText,"{%c%s%c:%s}",'"',"battery",'"',"20");
000038  a021              ADR      r0,|L2.192|
00003a  2122              MOVS     r1,#0x22
00003c  a321              ADR      r3,|L2.196|
00003e  460a              MOV      r2,r1
000040  e9cd1000          STRD     r1,r0,[sp,#0]
000044  a121              ADR      r1,|L2.204|
000046  4824              LDR      r0,|L2.216|
000048  f7fffffe          BL       __2sprintf
;;;120    //	expressText[0] = 0x31;
;;;121    	USART_OUT(USART1, "expressText66=%s\r\n", expressText);
00004c  4a22              LDR      r2,|L2.216|
00004e  a123              ADR      r1,|L2.220|
000050  4827              LDR      r0,|L2.240|
000052  f7fffffe          BL       USART_OUT
;;;122    	
;;;123    
;;;124    	
;;;125    //	USART_OUT(USART1, "in=%s\r\n", in);
;;;126    //	USART_OUT(USART1, "out=%s\r\n", out);
;;;127    //	AES_init_ctx(&ctx, key);
;;;128    //	AES_ECB_encrypt(&ctx, in);
;;;129    //	USART_OUT(USART1, "in=%s\r\n", in);
;;;130    //	USART_OUT(USART1, "out=%s\r\n", out);
;;;131        AES_init_ctx(&ctx, aesKey);
000056  4927              LDR      r1,|L2.244|
000058  a803              ADD      r0,sp,#0xc
00005a  f7fffffe          BL       AES_init_ctx
;;;132        AES_ECB_encrypt(&ctx, expressText);
00005e  491e              LDR      r1,|L2.216|
000060  a803              ADD      r0,sp,#0xc
000062  f7fffffe          BL       AES_ECB_encrypt
;;;133    
;;;134    	USART_OUT(USART1, expressText);
000066  491c              LDR      r1,|L2.216|
000068  4821              LDR      r0,|L2.240|
00006a  f7fffffe          BL       USART_OUT
;;;135    
;;;136        if (0 == memcmp((char*) out, (char*) in, 16))
00006e  2210              MOVS     r2,#0x10
000070  a933              ADD      r1,sp,#0xcc
000072  a837              ADD      r0,sp,#0xdc
000074  f7fffffe          BL       memcmp
000078  b920              CBNZ     r0,|L2.132|
;;;137        {
;;;138            USART_OUT(USART1, "SUCCESS!\n");
00007a  a11f              ADR      r1,|L2.248|
00007c  481c              LDR      r0,|L2.240|
00007e  f7fffffe          BL       USART_OUT
000082  e003              B        |L2.140|
                  |L2.132|
;;;139        }
;;;140        else
;;;141        {
;;;142            USART_OUT(USART1, "FAILURE!\n");
000084  a11f              ADR      r1,|L2.260|
000086  481a              LDR      r0,|L2.240|
000088  f7fffffe          BL       USART_OUT
                  |L2.140|
;;;143        }
;;;144    }
00008c  b03f              ADD      sp,sp,#0xfc
00008e  bd00              POP      {pc}
;;;145    
                          ENDP

                  |L2.144|
000090  2b7e1516          DCB      "+~",21,22,"(",174,210,166,171,247,21,136,"\t",207,"O<"
000094  28aed2a6
000098  abf71588
00009c  09cf4f3c
                  |L2.160|
0000a0  3ad77bb4          DCB      ":",215,"{",180,"\rz6`",168,158,202,243,"$$f",239,151
0000a4  0d7a3660
0000a8  a89ecaf3
0000ac  2466ef97
                  |L2.176|
0000b0  6bc1bee2          DCB      "k",193,190,226,".@",159,150,233,"=~",17,"s",147,23,"*"
0000b4  2e409f96
0000b8  e93d7e11
0000bc  7393172a
                  |L2.192|
0000c0  323000            DCB      "20",0
0000c3  00                DCB      0
                  |L2.196|
0000c4  62617474          DCB      "battery",0
0000c8  65727900
                  |L2.204|
0000cc  7b256325          DCB      "{%c%s%c:%s}",0
0000d0  7325633a
0000d4  25737d00
                  |L2.216|
                          DCD      expressText
                  |L2.220|
0000dc  65787072          DCB      "expressText66=%s\r\n",0
0000e0  65737354
0000e4  65787436
0000e8  363d2573
0000ec  0d0a00  
0000ef  00                DCB      0
                  |L2.240|
                          DCD      0x40013800
                  |L2.244|
                          DCD      aesKey
                  |L2.248|
0000f8  53554343          DCB      "SUCCESS!\n",0
0000fc  45535321
000100  0a00    
000102  00                DCB      0
000103  00                DCB      0
                  |L2.260|
000104  4641494c          DCB      "FAILURE!\n",0
000108  55524521
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  receiveText
                          %        24
                  expressText
                          %        512
                  cipherText
                          %        512
                  aesKey
                          %        16
                  gpsx
                          %        166
                  longitudedtbuf
                          %        30
                  latitudedtbuf
                          %        30
                  dtbuf
                          %        50
                  lockbuf
                          %        16
                  lockbuff
                          %        16
                  send_buff
                          %        100
                  protocol_buff
                          %        512
                  gps_buff
                          %        512
                  tmp
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  bell_flag
000000  00                DCB      0x00
                  Shaking
000001  00                DCB      0x00
                  Shaking_Alarm_Flag
000002  0000              DCB      0x00,0x00
                  Bat_V
000004  0000              DCB      0x00,0x00
                  Bat_Pre
000006  0000              DCB      0x00,0x00
                  Bat_Pre_Flag
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  ||p1||
                          DCD      0x00000000
                  ||p2||
                          DCD      0x00000000
                  lock_open_err_flag
000014  00                DCB      0x00
                  lock_close_err_flag
000015  00                DCB      0x00
                  Lock_Open
000016  00                DCB      0x00
                  Lock_Open_On
000017  00                DCB      0x00
                  Lock_Open_Off
000018  00                DCB      0x00
                  Lock_Close
000019  00                DCB      0x00
                  Lock_Close_On
00001a  00                DCB      0x00
                  Lock_Close_Off
00001b  00                DCB      0x00
                  lock_open_success_flag
00001c  00                DCB      0x00
                  flag
00001d  04                DCB      0x04
                  second_flag
00001e  00                DCB      0x00
                  LOCK_ON_flag
00001f  01                DCB      0x01
                  LOCK_OFF_flag
000020  01                DCB      0x01
                  gps_flag
000021  00                DCB      0x00
                  gps_err_cnt
000022  00                DCB      0x00
                  heartbeat_buff
000023  00                DCB      0x00
000024  00                DCB      0x00
                  mqtt_flag
000025  00                DCB      0x00

                  __ARM_use_no_argv EQU 0

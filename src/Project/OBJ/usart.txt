; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usart.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\driver -I..\BSP -I..\system -I..\tplib -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\app -I..\MQTT -IE:\github\dk-lock\src\Project\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=.\obj\usart.crf ..\driver\usart.c]
                          THUMB

                          AREA ||i.UART4_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART4_IRQHandler PROC
;;;367    */
;;;368    void UART4_IRQHandler(void)
000000  b508              PUSH     {r3,lr}
;;;369    {
;;;370    	u8 ch = 0;	
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;371    
;;;372       	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)
000006  f2405125          MOV      r1,#0x525
00000a  4820              LDR      r0,|L1.140|
00000c  f7fffffe          BL       USART_GetITStatus
000010  b338              CBZ      r0,|L1.98|
;;;373        {   
;;;374    	    USART_ClearITPendingBit(UART4, USART_IT_RXNE);	
000012  f2405125          MOV      r1,#0x525
000016  481d              LDR      r0,|L1.140|
000018  f7fffffe          BL       USART_ClearITPendingBit
;;;375    		timer_is_timeout_1ms(timer_uart4, 0);
00001c  2100              MOVS     r1,#0
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       timer_is_timeout_1ms
;;;376    		
;;;377    //		if(usart4_rx_status == 0)
;;;378    		{
;;;379    			ch = USART_ReceiveData(UART4);	 
000024  4819              LDR      r0,|L1.140|
000026  f7fffffe          BL       USART_ReceiveData
00002a  b2c0              UXTB     r0,r0
00002c  9000              STR      r0,[sp,#0]
;;;380    			
;;;381    			if (usart4_rx_buff->index < USART_BUFF_LENGHT)
00002e  4818              LDR      r0,|L1.144|
000030  6800              LDR      r0,[r0,#0]  ; usart4_rx_buff
000032  8800              LDRH     r0,[r0,#0]
000034  f5b07f00          CMP      r0,#0x200
000038  da14              BGE      |L1.100|
;;;382    			{			
;;;383    				usart4_rx_buff->pdata[usart4_rx_buff->index++] = ch;
00003a  f89d1000          LDRB     r1,[sp,#0]
00003e  4814              LDR      r0,|L1.144|
000040  6800              LDR      r0,[r0,#0]  ; usart4_rx_buff
000042  8802              LDRH     r2,[r0,#0]
000044  4812              LDR      r0,|L1.144|
000046  6800              LDR      r0,[r0,#0]  ; usart4_rx_buff
000048  8800              LDRH     r0,[r0,#0]
00004a  1c40              ADDS     r0,r0,#1
00004c  4b10              LDR      r3,|L1.144|
00004e  681b              LDR      r3,[r3,#0]  ; usart4_rx_buff
000050  8018              STRH     r0,[r3,#0]
000052  480f              LDR      r0,|L1.144|
000054  6800              LDR      r0,[r0,#0]  ; usart4_rx_buff
000056  1c80              ADDS     r0,r0,#2
000058  5481              STRB     r1,[r0,r2]
;;;384    				USART_OUT(UART4, &ch);
00005a  4669              MOV      r1,sp
00005c  480b              LDR      r0,|L1.140|
00005e  f7fffffe          BL       USART_OUT
                  |L1.98|
000062  e005              B        |L1.112|
                  |L1.100|
;;;385    			}
;;;386    			else
;;;387    			{
;;;388    				memset(usart4_rx_buff, 0, sizeof(usart_buff_t));	//清理缓冲区
000064  f2402102          MOV      r1,#0x202
000068  4809              LDR      r0,|L1.144|
00006a  6800              LDR      r0,[r0,#0]  ; usart4_rx_buff
00006c  f7fffffe          BL       __aeabi_memclr
                  |L1.112|
;;;389    			}
;;;390    		}	
;;;391    	}
;;;392    	
;;;393    	if(USART_GetITStatus(UART4, USART_IT_TXE) != RESET)                  
000070  f2407127          MOV      r1,#0x727
000074  4805              LDR      r0,|L1.140|
000076  f7fffffe          BL       USART_GetITStatus
00007a  b128              CBZ      r0,|L1.136|
;;;394      	{ 
;;;395         	USART_ITConfig(UART4, USART_IT_TXE, DISABLE);					   
00007c  2200              MOVS     r2,#0
00007e  f2407127          MOV      r1,#0x727
000082  4802              LDR      r0,|L1.140|
000084  f7fffffe          BL       USART_ITConfig
                  |L1.136|
;;;396      	}	
;;;397    	
;;;398    }
000088  bd08              POP      {r3,pc}
;;;399    
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      0x40004c00
                  |L1.144|
                          DCD      usart4_rx_buff

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;241    */
;;;242    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244    
;;;245    	u8 ch = 0;	
000002  2400              MOVS     r4,#0
;;;246    	
;;;247       	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  481d              LDR      r0,|L2.128|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b318              CBZ      r0,|L2.88|
;;;248        {   
;;;249    	    USART_ClearITPendingBit(USART1, USART_IT_RXNE);	
000010  f2405125          MOV      r1,#0x525
000014  481a              LDR      r0,|L2.128|
000016  f7fffffe          BL       USART_ClearITPendingBit
;;;250    				
;;;251            ch = USART_ReceiveData(USART1);	 
00001a  4819              LDR      r0,|L2.128|
00001c  f7fffffe          BL       USART_ReceiveData
000020  b2c4              UXTB     r4,r0
;;;252    		
;;;253    		timer_is_timeout_1ms(timer_uart1, 0);
000022  2100              MOVS     r1,#0
000024  200d              MOVS     r0,#0xd
000026  f7fffffe          BL       timer_is_timeout_1ms
;;;254    		
;;;255    		if(usart1_rx_status == 0)
00002a  4816              LDR      r0,|L2.132|
00002c  7800              LDRB     r0,[r0,#0]  ; usart1_rx_status
00002e  b998              CBNZ     r0,|L2.88|
;;;256    		{
;;;257    			if (usart1_rx_buff->index < USART_BUFF_LENGHT)
000030  4815              LDR      r0,|L2.136|
000032  6800              LDR      r0,[r0,#0]  ; usart1_rx_buff
000034  8800              LDRH     r0,[r0,#0]
000036  f5b07f00          CMP      r0,#0x200
00003a  da0e              BGE      |L2.90|
;;;258    			{	
;;;259    				usart1_rx_buff->pdata[usart1_rx_buff->index++] = ch;
00003c  4812              LDR      r0,|L2.136|
00003e  6800              LDR      r0,[r0,#0]  ; usart1_rx_buff
000040  8801              LDRH     r1,[r0,#0]
000042  4811              LDR      r0,|L2.136|
000044  6800              LDR      r0,[r0,#0]  ; usart1_rx_buff
000046  8800              LDRH     r0,[r0,#0]
000048  1c40              ADDS     r0,r0,#1
00004a  4a0f              LDR      r2,|L2.136|
00004c  6812              LDR      r2,[r2,#0]  ; usart1_rx_buff
00004e  8010              STRH     r0,[r2,#0]
000050  480d              LDR      r0,|L2.136|
000052  6800              LDR      r0,[r0,#0]  ; usart1_rx_buff
000054  1c80              ADDS     r0,r0,#2
000056  5444              STRB     r4,[r0,r1]
                  |L2.88|
000058  e005              B        |L2.102|
                  |L2.90|
;;;260    //				usart1_rx_status = 1;
;;;261    			}
;;;262    			else
;;;263    			{
;;;264    				memset(usart1_rx_buff, 0, sizeof(usart_buff_t));	//清理缓冲区		
00005a  f2402102          MOV      r1,#0x202
00005e  480a              LDR      r0,|L2.136|
000060  6800              LDR      r0,[r0,#0]  ; usart1_rx_buff
000062  f7fffffe          BL       __aeabi_memclr
                  |L2.102|
;;;265    			}
;;;266    		}
;;;267    	}
;;;268    	
;;;269    	if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)                  
000066  f2407127          MOV      r1,#0x727
00006a  4805              LDR      r0,|L2.128|
00006c  f7fffffe          BL       USART_GetITStatus
000070  b128              CBZ      r0,|L2.126|
;;;270      	{ 
;;;271         	USART_ITConfig(USART1, USART_IT_TXE, DISABLE);					   
000072  2200              MOVS     r2,#0
000074  f2407127          MOV      r1,#0x727
000078  4801              LDR      r0,|L2.128|
00007a  f7fffffe          BL       USART_ITConfig
                  |L2.126|
;;;272      	}		
;;;273    
;;;274    }
00007e  bd10              POP      {r4,pc}
;;;275    
                          ENDP

                  |L2.128|
                          DCD      0x40013800
                  |L2.132|
                          DCD      usart1_rx_status
                  |L2.136|
                          DCD      usart1_rx_buff

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;305    */
;;;306    void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;307    {
;;;308    	u8 ch = 0;	
000002  2400              MOVS     r4,#0
;;;309    
;;;310       	if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  481c              LDR      r0,|L3.124|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b300              CBZ      r0,|L3.82|
;;;311        {   
;;;312    	    USART_ClearITPendingBit(USART2, USART_IT_RXNE);	
000010  f2405125          MOV      r1,#0x525
000014  4819              LDR      r0,|L3.124|
000016  f7fffffe          BL       USART_ClearITPendingBit
;;;313    		
;;;314    		timer_is_timeout_1ms(timer_uart2, 0);		//定时器清零
00001a  2100              MOVS     r1,#0
00001c  200e              MOVS     r0,#0xe
00001e  f7fffffe          BL       timer_is_timeout_1ms
;;;315    		
;;;316    //		if(usart2_rx_status == 0)
;;;317    		{
;;;318    			ch = USART_ReceiveData(USART2);	 
000022  4816              LDR      r0,|L3.124|
000024  f7fffffe          BL       USART_ReceiveData
000028  b2c4              UXTB     r4,r0
;;;319    			
;;;320    			if (usart2_rx_buff->index < USART_BUFF_LENGHT)
00002a  4815              LDR      r0,|L3.128|
00002c  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
00002e  8800              LDRH     r0,[r0,#0]
000030  f5b07f00          CMP      r0,#0x200
000034  da0e              BGE      |L3.84|
;;;321    			{			
;;;322    				usart2_rx_buff->pdata[usart2_rx_buff->index++] = ch;
000036  4812              LDR      r0,|L3.128|
000038  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
00003a  8801              LDRH     r1,[r0,#0]
00003c  4810              LDR      r0,|L3.128|
00003e  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
000040  8800              LDRH     r0,[r0,#0]
000042  1c40              ADDS     r0,r0,#1
000044  4a0e              LDR      r2,|L3.128|
000046  6812              LDR      r2,[r2,#0]  ; usart2_rx_buff
000048  8010              STRH     r0,[r2,#0]
00004a  480d              LDR      r0,|L3.128|
00004c  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
00004e  1c80              ADDS     r0,r0,#2
000050  5444              STRB     r4,[r0,r1]
                  |L3.82|
000052  e005              B        |L3.96|
                  |L3.84|
;;;323    //				USART_OUT(USART1, &ch);
;;;324    			}
;;;325    			else
;;;326    			{
;;;327    				memset(usart2_rx_buff, 0, sizeof(usart_buff_t));	//清理缓冲区
000054  f2402102          MOV      r1,#0x202
000058  4809              LDR      r0,|L3.128|
00005a  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
00005c  f7fffffe          BL       __aeabi_memclr
                  |L3.96|
;;;328    			}
;;;329    		}
;;;330    	}
;;;331    	
;;;332    	if(USART_GetITStatus(USART2, USART_IT_TXE) != RESET)                  
000060  f2407127          MOV      r1,#0x727
000064  4805              LDR      r0,|L3.124|
000066  f7fffffe          BL       USART_GetITStatus
00006a  b128              CBZ      r0,|L3.120|
;;;333      	{ 
;;;334         	USART_ITConfig(USART2, USART_IT_TXE, DISABLE);					   
00006c  2200              MOVS     r2,#0
00006e  f2407127          MOV      r1,#0x727
000072  4802              LDR      r0,|L3.124|
000074  f7fffffe          BL       USART_ITConfig
                  |L3.120|
;;;335      	}	
;;;336     	
;;;337    }
000078  bd10              POP      {r4,pc}
;;;338    
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
                          DCD      0x40004400
                  |L3.128|
                          DCD      usart2_rx_buff

                          AREA ||i.USART_OUT||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  USART_OUT PROC
;;;445    */
;;;446    void USART_OUT(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;447    { 
000002  b570              PUSH     {r4-r6,lr}
000004  b08a              SUB      sp,sp,#0x28
000006  4606              MOV      r6,r0
;;;448    	const char *s;
;;;449        int d;  
;;;450        char buf[32];
;;;451        
;;;452    	va_list ap;
;;;453        __va_start(ap, Data);
000008  a810              ADD      r0,sp,#0x40
00000a  9001              STR      r0,[sp,#4]
;;;454    	
;;;455    	
;;;456    	USART_GetFlagStatus(USARTx, USART_FLAG_TC);	//
00000c  2140              MOVS     r1,#0x40
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       USART_GetFlagStatus
;;;457    	while(*Data != '\0')
000014  e073              B        |L4.254|
                  |L4.22|
;;;458    	{				                         
;;;459    		if(*Data==0x5c)
000016  980f              LDR      r0,[sp,#0x3c]
000018  7800              LDRB     r0,[r0,#0]
00001a  285c              CMP      r0,#0x5c
00001c  d11c              BNE      |L4.88|
;;;460    		{									
;;;461    			switch (*++Data)
00001e  980f              LDR      r0,[sp,#0x3c]
000020  1c40              ADDS     r0,r0,#1
000022  900f              STR      r0,[sp,#0x3c]
000024  7800              LDRB     r0,[r0,#0]
000026  286e              CMP      r0,#0x6e
000028  d009              BEQ      |L4.62|
00002a  2872              CMP      r0,#0x72
00002c  d10f              BNE      |L4.78|
;;;462    			{
;;;463    				case 'r':							          
;;;464    					USART_SendData(USARTx, 0x0d);	   
00002e  210d              MOVS     r1,#0xd
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       USART_SendData
;;;465    					Data++;
000036  980f              LDR      r0,[sp,#0x3c]
000038  1c40              ADDS     r0,r0,#1
00003a  900f              STR      r0,[sp,#0x3c]
;;;466    				break;
00003c  e00b              B        |L4.86|
                  |L4.62|
;;;467    				case 'n':							          
;;;468    					USART_SendData(USARTx, 0x0a);	
00003e  210a              MOVS     r1,#0xa
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       USART_SendData
;;;469    					Data++;
000046  980f              LDR      r0,[sp,#0x3c]
000048  1c40              ADDS     r0,r0,#1
00004a  900f              STR      r0,[sp,#0x3c]
;;;470    				break;
00004c  e003              B        |L4.86|
                  |L4.78|
;;;471    				
;;;472    				default:
;;;473    					Data++;
00004e  980f              LDR      r0,[sp,#0x3c]
000050  1c40              ADDS     r0,r0,#1
000052  900f              STR      r0,[sp,#0x3c]
;;;474    			    break;
000054  bf00              NOP      
                  |L4.86|
000056  e04b              B        |L4.240|
                  |L4.88|
;;;475    			}						 
;;;476    		}
;;;477    		else if(*Data=='%')
000058  980f              LDR      r0,[sp,#0x3c]
00005a  7800              LDRB     r0,[r0,#0]
00005c  2825              CMP      r0,#0x25
00005e  d140              BNE      |L4.226|
;;;478    		{									  //
;;;479    			switch (*++Data){				
000060  980f              LDR      r0,[sp,#0x3c]
000062  1c40              ADDS     r0,r0,#1
000064  900f              STR      r0,[sp,#0x3c]
000066  7800              LDRB     r0,[r0,#0]
000068  2864              CMP      r0,#0x64
00006a  d018              BEQ      |L4.158|
00006c  2873              CMP      r0,#0x73
00006e  d133              BNE      |L4.216|
;;;480    				case 's':										  
;;;481                    	s = __va_arg(ap, const char *);
000070  9801              LDR      r0,[sp,#4]
000072  c810              LDM      r0!,{r4}
000074  9001              STR      r0,[sp,#4]
;;;482                    	for ( ; *s; s++) 
000076  e00b              B        |L4.144|
                  |L4.120|
;;;483    					{
;;;484                        	USART_SendData(USARTx,*s);
000078  7821              LDRB     r1,[r4,#0]
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       USART_SendData
;;;485    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
000080  bf00              NOP      
                  |L4.130|
000082  2140              MOVS     r1,#0x40
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       USART_GetFlagStatus
00008a  2800              CMP      r0,#0
00008c  d0f9              BEQ      |L4.130|
00008e  1c64              ADDS     r4,r4,#1              ;482
                  |L4.144|
000090  7820              LDRB     r0,[r4,#0]            ;482
000092  2800              CMP      r0,#0                 ;482
000094  d1f0              BNE      |L4.120|
;;;486                    	}
;;;487    					Data++;
000096  980f              LDR      r0,[sp,#0x3c]
000098  1c40              ADDS     r0,r0,#1
00009a  900f              STR      r0,[sp,#0x3c]
;;;488                    	break;
00009c  e020              B        |L4.224|
                  |L4.158|
;;;489                	case 'd':										 
;;;490                    	d = __va_arg(ap, int);
00009e  9801              LDR      r0,[sp,#4]
0000a0  c820              LDM      r0!,{r5}
0000a2  9001              STR      r0,[sp,#4]
;;;491    					
;;;492    					sprintf(buf, "%d", d);
0000a4  462a              MOV      r2,r5
0000a6  a11a              ADR      r1,|L4.272|
0000a8  a802              ADD      r0,sp,#8
0000aa  f7fffffe          BL       __2sprintf
;;;493                    	for (s = buf; *s; s++) 
0000ae  ac02              ADD      r4,sp,#8
0000b0  e00b              B        |L4.202|
                  |L4.178|
;;;494    					{
;;;495                        	USART_SendData(USARTx,*s);
0000b2  7821              LDRB     r1,[r4,#0]
0000b4  4630              MOV      r0,r6
0000b6  f7fffffe          BL       USART_SendData
;;;496    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
0000ba  bf00              NOP      
                  |L4.188|
0000bc  2140              MOVS     r1,#0x40
0000be  4630              MOV      r0,r6
0000c0  f7fffffe          BL       USART_GetFlagStatus
0000c4  2800              CMP      r0,#0
0000c6  d0f9              BEQ      |L4.188|
0000c8  1c64              ADDS     r4,r4,#1              ;493
                  |L4.202|
0000ca  7820              LDRB     r0,[r4,#0]            ;493
0000cc  2800              CMP      r0,#0                 ;493
0000ce  d1f0              BNE      |L4.178|
;;;497                    	}
;;;498    					Data++;
0000d0  980f              LDR      r0,[sp,#0x3c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900f              STR      r0,[sp,#0x3c]
;;;499                    	break;
0000d6  e003              B        |L4.224|
                  |L4.216|
;;;500    				default:
;;;501    					Data++;
0000d8  980f              LDR      r0,[sp,#0x3c]
0000da  1c40              ADDS     r0,r0,#1
0000dc  900f              STR      r0,[sp,#0x3c]
;;;502    				    break;
0000de  bf00              NOP      
                  |L4.224|
0000e0  e006              B        |L4.240|
                  |L4.226|
;;;503    			}		 
;;;504    		}
;;;505    		else 
;;;506    			USART_SendData(USARTx, *Data++);
0000e2  980f              LDR      r0,[sp,#0x3c]
0000e4  f8101b01          LDRB     r1,[r0],#1
0000e8  900f              STR      r0,[sp,#0x3c]
0000ea  4630              MOV      r0,r6
0000ec  f7fffffe          BL       USART_SendData
                  |L4.240|
;;;507    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
0000f0  bf00              NOP      
                  |L4.242|
0000f2  2140              MOVS     r1,#0x40
0000f4  4630              MOV      r0,r6
0000f6  f7fffffe          BL       USART_GetFlagStatus
0000fa  2800              CMP      r0,#0
0000fc  d0f9              BEQ      |L4.242|
                  |L4.254|
0000fe  980f              LDR      r0,[sp,#0x3c]         ;457
000100  7800              LDRB     r0,[r0,#0]            ;457
000102  2800              CMP      r0,#0                 ;457
000104  d187              BNE      |L4.22|
;;;508    	}
;;;509    }
000106  b00a              ADD      sp,sp,#0x28
000108  bc70              POP      {r4-r6}
00010a  f85dfb14          LDR      pc,[sp],#0x14
;;;510    
                          ENDP

00010e  0000              DCW      0x0000
                  |L4.272|
000110  256400            DCB      "%d",0
000113  00                DCB      0

                          AREA ||i.usart1_init||, CODE, READONLY, ALIGN=2

                  usart1_init PROC
;;;132    */
;;;133    void usart1_init(u32 band_rate, u8 word_length, u8 parity, u8 stop_bit)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;134    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;135    	
;;;136    	USART_InitTypeDef usart_init_structre;
;;;137    	
;;;138    	usart_init_structre.USART_BaudRate = band_rate;
00000c  9700              STR      r7,[sp,#0]
;;;139    	usart_init_structre.USART_WordLength = word_length;
00000e  f8ad4004          STRH     r4,[sp,#4]
;;;140    	usart_init_structre.USART_StopBits = stop_bit;
000012  f8ad6006          STRH     r6,[sp,#6]
;;;141    	usart_init_structre.USART_Parity = parity;
000016  f8ad5008          STRH     r5,[sp,#8]
;;;142    	usart_init_structre.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00001a  2000              MOVS     r0,#0
00001c  f8ad000c          STRH     r0,[sp,#0xc]
;;;143    	usart_init_structre.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000020  200c              MOVS     r0,#0xc
000022  f8ad000a          STRH     r0,[sp,#0xa]
;;;144    	USART_Init(USART1, &usart_init_structre);
000026  4669              MOV      r1,sp
000028  4807              LDR      r0,|L5.72|
00002a  f7fffffe          BL       USART_Init
;;;145    		
;;;146    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00002e  2201              MOVS     r2,#1
000030  f2405125          MOV      r1,#0x525
000034  4804              LDR      r0,|L5.72|
000036  f7fffffe          BL       USART_ITConfig
;;;147    	
;;;148    	USART_Cmd(USART1, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  4802              LDR      r0,|L5.72|
00003e  f7fffffe          BL       USART_Cmd
;;;149    	
;;;150    }
000042  e8bd81ff          POP      {r0-r8,pc}
;;;151    
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      0x40013800

                          AREA ||i.usart1_recv_data||, CODE, READONLY, ALIGN=2

                  usart1_recv_data PROC
;;;275    
;;;276    void usart1_recv_data(void)
000000  b510              PUSH     {r4,lr}
;;;277    {
;;;278    
;;;279    	if(timer_is_timeout_1ms(timer_uart1, 20) == 0)	//40ms没接收到数据认为接收数据完成		
000002  2114              MOVS     r1,#0x14
000004  200d              MOVS     r0,#0xd
000006  f7fffffe          BL       timer_is_timeout_1ms
00000a  b958              CBNZ     r0,|L6.36|
;;;280    	{
;;;281    		
;;;282    //		memcpy(gprs_buff, usart1_rx_buff, sizeof(usart_buff_t));
;;;283    		
;;;284    		USART_OUT(USART1, usart1_rx_buff->pdata);
00000c  4806              LDR      r0,|L6.40|
00000e  6801              LDR      r1,[r0,#0]  ; usart1_rx_buff
000010  1c89              ADDS     r1,r1,#2
000012  4806              LDR      r0,|L6.44|
000014  f7fffffe          BL       USART_OUT
;;;285    		
;;;286    		memset(usart1_rx_buff, 0, sizeof(usart_buff_t));
000018  f2402102          MOV      r1,#0x202
00001c  4802              LDR      r0,|L6.40|
00001e  6800              LDR      r0,[r0,#0]  ; usart1_rx_buff
000020  f7fffffe          BL       __aeabi_memclr
                  |L6.36|
;;;287    	}
;;;288    
;;;289    }
000024  bd10              POP      {r4,pc}
;;;290    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      usart1_rx_buff
                  |L6.44|
                          DCD      0x40013800

                          AREA ||i.usart2_init||, CODE, READONLY, ALIGN=2

                  usart2_init PROC
;;;170    */
;;;171    void usart2_init(u32 band_rate)
000000  b51f              PUSH     {r0-r4,lr}
;;;172    {
000002  4604              MOV      r4,r0
;;;173    	USART_InitTypeDef usart_init_structre;
;;;174    	
;;;175    	usart_init_structre.USART_BaudRate = band_rate;
000004  9400              STR      r4,[sp,#0]
;;;176    	usart_init_structre.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;177    	usart_init_structre.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;178    	usart_init_structre.USART_Parity = USART_Parity_No;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;179    	usart_init_structre.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;180    	usart_init_structre.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;181    	USART_Init(USART2, &usart_init_structre);
00001e  4669              MOV      r1,sp
000020  4806              LDR      r0,|L7.60|
000022  f7fffffe          BL       USART_Init
;;;182    		
;;;183    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000026  2201              MOVS     r2,#1
000028  f2405125          MOV      r1,#0x525
00002c  4803              LDR      r0,|L7.60|
00002e  f7fffffe          BL       USART_ITConfig
;;;184    	
;;;185    	USART_Cmd(USART2, ENABLE);
000032  2101              MOVS     r1,#1
000034  4801              LDR      r0,|L7.60|
000036  f7fffffe          BL       USART_Cmd
;;;186    	
;;;187    }
00003a  bd1f              POP      {r0-r4,pc}
;;;188    
                          ENDP

                  |L7.60|
                          DCD      0x40004400

                          AREA ||i.usart2_recv_data||, CODE, READONLY, ALIGN=2

                  usart2_recv_data PROC
;;;339    
;;;340    void usart2_recv_data(void)
000000  b510              PUSH     {r4,lr}
;;;341    {		
;;;342    	if(timer_is_timeout_1ms(timer_uart2, 20) == 0)	//20ms没接收到数据认为接收数据完成		
000002  2114              MOVS     r1,#0x14
000004  200e              MOVS     r0,#0xe
000006  f7fffffe          BL       timer_is_timeout_1ms
00000a  b9b0              CBNZ     r0,|L8.58|
;;;343    	{
;;;344    //		USART_OUT(USART1, usart2_rx_buff->pdata);
;;;345    		memcpy(mqtt_buff, usart2_rx_buff, sizeof(usart_buff_t));
00000c  f2402202          MOV      r2,#0x202
000010  480a              LDR      r0,|L8.60|
000012  6801              LDR      r1,[r0,#0]  ; usart2_rx_buff
000014  480a              LDR      r0,|L8.64|
000016  6800              LDR      r0,[r0,#0]  ; mqtt_buff
000018  f7fffffe          BL       __aeabi_memcpy
;;;346    		usart_send(USART1, mqtt_buff->pdata, mqtt_buff->index);
00001c  4808              LDR      r0,|L8.64|
00001e  6800              LDR      r0,[r0,#0]  ; mqtt_buff
000020  8802              LDRH     r2,[r0,#0]
000022  4807              LDR      r0,|L8.64|
000024  6801              LDR      r1,[r0,#0]  ; mqtt_buff
000026  1c89              ADDS     r1,r1,#2
000028  4806              LDR      r0,|L8.68|
00002a  f7fffffe          BL       usart_send
;;;347    		memset(usart2_rx_buff, 0, sizeof(usart_buff_t));	//清理缓冲区
00002e  f2402102          MOV      r1,#0x202
000032  4802              LDR      r0,|L8.60|
000034  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
000036  f7fffffe          BL       __aeabi_memclr
                  |L8.58|
;;;348    	}	
;;;349    }
00003a  bd10              POP      {r4,pc}
;;;350    
                          ENDP

                  |L8.60|
                          DCD      usart2_rx_buff
                  |L8.64|
                          DCD      mqtt_buff
                  |L8.68|
                          DCD      0x40013800

                          AREA ||i.usart4_init||, CODE, READONLY, ALIGN=2

                  usart4_init PROC
;;;206    */
;;;207    void usart4_init(u32 band_rate)
000000  b51f              PUSH     {r0-r4,lr}
;;;208    {
000002  4604              MOV      r4,r0
;;;209    	USART_InitTypeDef usart_init_structre;
;;;210    	
;;;211    	usart_init_structre.USART_BaudRate = band_rate;
000004  9400              STR      r4,[sp,#0]
;;;212    	usart_init_structre.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;213    	usart_init_structre.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;214    	usart_init_structre.USART_Parity = USART_Parity_No;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;215    	usart_init_structre.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;216    	usart_init_structre.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;217    	USART_Init(UART4, &usart_init_structre);
00001e  4669              MOV      r1,sp
000020  4806              LDR      r0,|L9.60|
000022  f7fffffe          BL       USART_Init
;;;218    		
;;;219    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
000026  2201              MOVS     r2,#1
000028  f2405125          MOV      r1,#0x525
00002c  4803              LDR      r0,|L9.60|
00002e  f7fffffe          BL       USART_ITConfig
;;;220    	
;;;221    	USART_Cmd(UART4, ENABLE);
000032  2101              MOVS     r1,#1
000034  4801              LDR      r0,|L9.60|
000036  f7fffffe          BL       USART_Cmd
;;;222    	
;;;223    }
00003a  bd1f              POP      {r0-r4,pc}
;;;224    
                          ENDP

                  |L9.60|
                          DCD      0x40004c00

                          AREA ||i.usart4_recv_data||, CODE, READONLY, ALIGN=2

                  usart4_recv_data PROC
;;;414    */
;;;415    void usart4_recv_data(void)
000000  b510              PUSH     {r4,lr}
;;;416    {
;;;417    	if(timer_is_timeout_1ms(timer_uart4, 20) == 0)	//20ms没接收到数据认为接收数据完成		
000002  2114              MOVS     r1,#0x14
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       timer_is_timeout_1ms
00000a  b958              CBNZ     r0,|L10.36|
;;;418    	{
;;;419    		USART_OUT(UART4, usart4_rx_buff->pdata);
00000c  4806              LDR      r0,|L10.40|
00000e  6801              LDR      r1,[r0,#0]  ; usart4_rx_buff
000010  1c89              ADDS     r1,r1,#2
000012  4806              LDR      r0,|L10.44|
000014  f7fffffe          BL       USART_OUT
;;;420    		memset(usart2_rx_buff, 0, sizeof(usart_buff_t));	//清理缓冲区
000018  f2402102          MOV      r1,#0x202
00001c  4804              LDR      r0,|L10.48|
00001e  6800              LDR      r0,[r0,#0]  ; usart2_rx_buff
000020  f7fffffe          BL       __aeabi_memclr
                  |L10.36|
;;;421    	}	
;;;422    }
000024  bd10              POP      {r4,pc}
;;;423    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      usart4_rx_buff
                  |L10.44|
                          DCD      0x40004c00
                  |L10.48|
                          DCD      usart2_rx_buff

                          AREA ||i.usart_gpio_init||, CODE, READONLY, ALIGN=2

                  usart_gpio_init PROC
;;;63     
;;;64     void usart_gpio_init(void)
000000  b508              PUSH     {r3,lr}
;;;65     {
;;;66     	GPIO_InitTypeDef gpio_init_structure;
;;;67     	
;;;68     		// UART1
;;;69     	gpio_init_structure.GPIO_Pin = GPIO_Pin_9;				// UART1 TX				    
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;70       	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;71       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;72       	GPIO_Init(GPIOA, &gpio_init_structure);
000016  4669              MOV      r1,sp
000018  4831              LDR      r0,|L11.224|
00001a  f7fffffe          BL       GPIO_Init
;;;73     	gpio_init_structure.GPIO_Pin = GPIO_Pin_10;				
00001e  f44f6080          MOV      r0,#0x400
000022  f8ad0000          STRH     r0,[sp,#0]
;;;74       	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2004              MOVS     r0,#4
000028  f88d0003          STRB     r0,[sp,#3]
;;;75       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
00002c  2003              MOVS     r0,#3
00002e  f88d0002          STRB     r0,[sp,#2]
;;;76       	GPIO_Init(GPIOA, &gpio_init_structure);
000032  4669              MOV      r1,sp
000034  482a              LDR      r0,|L11.224|
000036  f7fffffe          BL       GPIO_Init
;;;77     	
;;;78     	// UART2
;;;79     	gpio_init_structure.GPIO_Pin = GPIO_Pin_2;				// UART2 TX				    
00003a  2004              MOVS     r0,#4
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;80       	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
000040  2018              MOVS     r0,#0x18
000042  f88d0003          STRB     r0,[sp,#3]
;;;81       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
000046  2003              MOVS     r0,#3
000048  f88d0002          STRB     r0,[sp,#2]
;;;82       	GPIO_Init(GPIOA, &gpio_init_structure);
00004c  4669              MOV      r1,sp
00004e  4824              LDR      r0,|L11.224|
000050  f7fffffe          BL       GPIO_Init
;;;83     	gpio_init_structure.GPIO_Pin = GPIO_Pin_3;				
000054  2008              MOVS     r0,#8
000056  f8ad0000          STRH     r0,[sp,#0]
;;;84       	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00005a  2004              MOVS     r0,#4
00005c  f88d0003          STRB     r0,[sp,#3]
;;;85       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
000060  2003              MOVS     r0,#3
000062  f88d0002          STRB     r0,[sp,#2]
;;;86       	GPIO_Init(GPIOA, &gpio_init_structure);
000066  4669              MOV      r1,sp
000068  481d              LDR      r0,|L11.224|
00006a  f7fffffe          BL       GPIO_Init
;;;87     
;;;88     
;;;89     	// UART3
;;;90     	gpio_init_structure.GPIO_Pin = GPIO_Pin_10;				// UART3 TX				    
00006e  f44f6080          MOV      r0,#0x400
000072  f8ad0000          STRH     r0,[sp,#0]
;;;91       	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
000076  2018              MOVS     r0,#0x18
000078  f88d0003          STRB     r0,[sp,#3]
;;;92       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
00007c  2003              MOVS     r0,#3
00007e  f88d0002          STRB     r0,[sp,#2]
;;;93       	GPIO_Init(GPIOB, &gpio_init_structure);
000082  4669              MOV      r1,sp
000084  4817              LDR      r0,|L11.228|
000086  f7fffffe          BL       GPIO_Init
;;;94     	gpio_init_structure.GPIO_Pin = GPIO_Pin_11;				
00008a  f44f6000          MOV      r0,#0x800
00008e  f8ad0000          STRH     r0,[sp,#0]
;;;95       	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000092  2004              MOVS     r0,#4
000094  f88d0003          STRB     r0,[sp,#3]
;;;96       	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
000098  2003              MOVS     r0,#3
00009a  f88d0002          STRB     r0,[sp,#2]
;;;97       	GPIO_Init(GPIOB, &gpio_init_structure);
00009e  4669              MOV      r1,sp
0000a0  4810              LDR      r0,|L11.228|
0000a2  f7fffffe          BL       GPIO_Init
;;;98     	
;;;99     	
;;;100    	// UART4
;;;101    	gpio_init_structure.GPIO_Pin = GPIO_Pin_10;				// UART3 TX				    
0000a6  f44f6080          MOV      r0,#0x400
0000aa  f8ad0000          STRH     r0,[sp,#0]
;;;102      	gpio_init_structure.GPIO_Mode = GPIO_Mode_AF_PP;
0000ae  2018              MOVS     r0,#0x18
0000b0  f88d0003          STRB     r0,[sp,#3]
;;;103      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			
0000b4  2003              MOVS     r0,#3
0000b6  f88d0002          STRB     r0,[sp,#2]
;;;104      	GPIO_Init(GPIOC, &gpio_init_structure);
0000ba  4669              MOV      r1,sp
0000bc  480a              LDR      r0,|L11.232|
0000be  f7fffffe          BL       GPIO_Init
;;;105    	gpio_init_structure.GPIO_Pin = GPIO_Pin_11;				
0000c2  f44f6000          MOV      r0,#0x800
0000c6  f8ad0000          STRH     r0,[sp,#0]
;;;106      	gpio_init_structure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000ca  2004              MOVS     r0,#4
0000cc  f88d0003          STRB     r0,[sp,#3]
;;;107      	gpio_init_structure.GPIO_Speed = GPIO_Speed_50MHz;			 
0000d0  2003              MOVS     r0,#3
0000d2  f88d0002          STRB     r0,[sp,#2]
;;;108      	GPIO_Init(GPIOC, &gpio_init_structure);
0000d6  4669              MOV      r1,sp
0000d8  4803              LDR      r0,|L11.232|
0000da  f7fffffe          BL       GPIO_Init
;;;109    	
;;;110    
;;;111    }
0000de  bd08              POP      {r3,pc}
;;;112    
                          ENDP

                  |L11.224|
                          DCD      0x40010800
                  |L11.228|
                          DCD      0x40010c00
                  |L11.232|
                          DCD      0x40011000

                          AREA ||i.usart_send||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  usart_send PROC
;;;513    
;;;514    void usart_send(USART_TypeDef* USARTx, uint8_t *data, uint16_t data_size,...)
000000  b40f              PUSH     {r0-r3}
;;;515    { 
000002  b5f0              PUSH     {r4-r7,lr}
000004  b089              SUB      sp,sp,#0x24
000006  4607              MOV      r7,r0
000008  4615              MOV      r5,r2
;;;516    	const char *s;
;;;517        int d;  
;;;518        char buf[32];
;;;519        
;;;520    	va_list ap;
;;;521        __va_start(ap, data);
00000a  a810              ADD      r0,sp,#0x40
00000c  9000              STR      r0,[sp,#0]
;;;522    	
;;;523    	
;;;524    	USART_GetFlagStatus(USARTx, USART_FLAG_TC);	//
00000e  2140              MOVS     r1,#0x40
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       USART_GetFlagStatus
;;;525    	while(data_size--)
000016  e073              B        |L12.256|
                  |L12.24|
;;;526    	{				                         
;;;527    		if(*data==0x5c)
000018  980f              LDR      r0,[sp,#0x3c]
00001a  7800              LDRB     r0,[r0,#0]
00001c  285c              CMP      r0,#0x5c
00001e  d11c              BNE      |L12.90|
;;;528    		{									
;;;529    			switch (*++data)
000020  980f              LDR      r0,[sp,#0x3c]
000022  1c40              ADDS     r0,r0,#1
000024  900f              STR      r0,[sp,#0x3c]
000026  7800              LDRB     r0,[r0,#0]
000028  286e              CMP      r0,#0x6e
00002a  d009              BEQ      |L12.64|
00002c  2872              CMP      r0,#0x72
00002e  d10f              BNE      |L12.80|
;;;530    			{
;;;531    				case 'r':							          
;;;532    					USART_SendData(USARTx, 0x0d);	   
000030  210d              MOVS     r1,#0xd
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       USART_SendData
;;;533    					data++;
000038  980f              LDR      r0,[sp,#0x3c]
00003a  1c40              ADDS     r0,r0,#1
00003c  900f              STR      r0,[sp,#0x3c]
;;;534    				break;
00003e  e00b              B        |L12.88|
                  |L12.64|
;;;535    				case 'n':							          
;;;536    					USART_SendData(USARTx, 0x0a);	
000040  210a              MOVS     r1,#0xa
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       USART_SendData
;;;537    					data++;
000048  980f              LDR      r0,[sp,#0x3c]
00004a  1c40              ADDS     r0,r0,#1
00004c  900f              STR      r0,[sp,#0x3c]
;;;538    				break;
00004e  e003              B        |L12.88|
                  |L12.80|
;;;539    				
;;;540    				default:
;;;541    					data++;
000050  980f              LDR      r0,[sp,#0x3c]
000052  1c40              ADDS     r0,r0,#1
000054  900f              STR      r0,[sp,#0x3c]
;;;542    			    break;
000056  bf00              NOP      
                  |L12.88|
000058  e04b              B        |L12.242|
                  |L12.90|
;;;543    			}						 
;;;544    		}
;;;545    		else if(*data=='%')
00005a  980f              LDR      r0,[sp,#0x3c]
00005c  7800              LDRB     r0,[r0,#0]
00005e  2825              CMP      r0,#0x25
000060  d140              BNE      |L12.228|
;;;546    		{									  //
;;;547    			switch (*++data){				
000062  980f              LDR      r0,[sp,#0x3c]
000064  1c40              ADDS     r0,r0,#1
000066  900f              STR      r0,[sp,#0x3c]
000068  7800              LDRB     r0,[r0,#0]
00006a  2864              CMP      r0,#0x64
00006c  d018              BEQ      |L12.160|
00006e  2873              CMP      r0,#0x73
000070  d133              BNE      |L12.218|
;;;548    				case 's':										  
;;;549                    	s = __va_arg(ap, const char *);
000072  9800              LDR      r0,[sp,#0]
000074  c810              LDM      r0!,{r4}
000076  9000              STR      r0,[sp,#0]
;;;550                    	for ( ; *s; s++) 
000078  e00b              B        |L12.146|
                  |L12.122|
;;;551    					{
;;;552                        	USART_SendData(USARTx,*s);
00007a  7821              LDRB     r1,[r4,#0]
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       USART_SendData
;;;553    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
000082  bf00              NOP      
                  |L12.132|
000084  2140              MOVS     r1,#0x40
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       USART_GetFlagStatus
00008c  2800              CMP      r0,#0
00008e  d0f9              BEQ      |L12.132|
000090  1c64              ADDS     r4,r4,#1              ;550
                  |L12.146|
000092  7820              LDRB     r0,[r4,#0]            ;550
000094  2800              CMP      r0,#0                 ;550
000096  d1f0              BNE      |L12.122|
;;;554                    	}
;;;555    					data++;
000098  980f              LDR      r0,[sp,#0x3c]
00009a  1c40              ADDS     r0,r0,#1
00009c  900f              STR      r0,[sp,#0x3c]
;;;556                    	break;
00009e  e020              B        |L12.226|
                  |L12.160|
;;;557                	case 'd':										 
;;;558                    	d = __va_arg(ap, int);
0000a0  9800              LDR      r0,[sp,#0]
0000a2  c840              LDM      r0!,{r6}
0000a4  9000              STR      r0,[sp,#0]
;;;559    
;;;560    					sprintf(buf, "%d", d);
0000a6  4632              MOV      r2,r6
0000a8  a11a              ADR      r1,|L12.276|
0000aa  a801              ADD      r0,sp,#4
0000ac  f7fffffe          BL       __2sprintf
;;;561                    	for (s = buf; *s; s++) 
0000b0  ac01              ADD      r4,sp,#4
0000b2  e00b              B        |L12.204|
                  |L12.180|
;;;562    					{
;;;563                        	USART_SendData(USARTx,*s);
0000b4  7821              LDRB     r1,[r4,#0]
0000b6  4638              MOV      r0,r7
0000b8  f7fffffe          BL       USART_SendData
;;;564    						while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
0000bc  bf00              NOP      
                  |L12.190|
0000be  2140              MOVS     r1,#0x40
0000c0  4638              MOV      r0,r7
0000c2  f7fffffe          BL       USART_GetFlagStatus
0000c6  2800              CMP      r0,#0
0000c8  d0f9              BEQ      |L12.190|
0000ca  1c64              ADDS     r4,r4,#1              ;561
                  |L12.204|
0000cc  7820              LDRB     r0,[r4,#0]            ;561
0000ce  2800              CMP      r0,#0                 ;561
0000d0  d1f0              BNE      |L12.180|
;;;565                    	}
;;;566    					data++;
0000d2  980f              LDR      r0,[sp,#0x3c]
0000d4  1c40              ADDS     r0,r0,#1
0000d6  900f              STR      r0,[sp,#0x3c]
;;;567                    	break;
0000d8  e003              B        |L12.226|
                  |L12.218|
;;;568    				default:
;;;569    					data++;
0000da  980f              LDR      r0,[sp,#0x3c]
0000dc  1c40              ADDS     r0,r0,#1
0000de  900f              STR      r0,[sp,#0x3c]
;;;570    				    break;
0000e0  bf00              NOP      
                  |L12.226|
0000e2  e006              B        |L12.242|
                  |L12.228|
;;;571    			}		 
;;;572    		}
;;;573    		else 
;;;574    			USART_SendData(USARTx, *data++);
0000e4  980f              LDR      r0,[sp,#0x3c]
0000e6  f8101b01          LDRB     r1,[r0],#1
0000ea  900f              STR      r0,[sp,#0x3c]
0000ec  4638              MOV      r0,r7
0000ee  f7fffffe          BL       USART_SendData
                  |L12.242|
;;;575    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
0000f2  bf00              NOP      
                  |L12.244|
0000f4  2140              MOVS     r1,#0x40
0000f6  4638              MOV      r0,r7
0000f8  f7fffffe          BL       USART_GetFlagStatus
0000fc  2800              CMP      r0,#0
0000fe  d0f9              BEQ      |L12.244|
                  |L12.256|
000100  1e28              SUBS     r0,r5,#0              ;525
000102  f1a50101          SUB      r1,r5,#1              ;525
000106  b28d              UXTH     r5,r1                 ;525
000108  d186              BNE      |L12.24|
;;;576    	}
;;;577    	
;;;578    }
00010a  b009              ADD      sp,sp,#0x24
00010c  bcf0              POP      {r4-r7}
00010e  f85dfb14          LDR      pc,[sp],#0x14
;;;579    
                          ENDP

000112  0000              DCW      0x0000
                  |L12.276|
000114  256400            DCB      "%d",0
000117  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ||sb||
                          %        514

                          AREA ||.data||, DATA, ALIGN=2

                  usart1_rx_buff
                          DCD      ||sb||
                  usart2_rx_buff
                          DCD      ||sb||
                  usart3_rx_buff
                          DCD      ||sb||
                  usart4_rx_buff
                          DCD      ||sb||
                  mqtt_buff
                          DCD      ||sb||
                  usart1_rx_status
000014  00                DCB      0x00
                  usart2_rx_status
000015  00                DCB      0x00
                  usart3_rx_status
000016  00                DCB      0x00
                  usart4_rx_status
000017  00                DCB      0x00
                  usart5_rx_status
000018  00                DCB      0x00

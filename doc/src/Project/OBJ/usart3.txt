; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\usart3.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\usart3.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\USER -I..\BSP\24CXX -I..\BSP\ADC -I..\BSP\GPS -I..\BSP\IIC -I..\BSP\RTC -I..\BSP\TIMER -I..\BSP\USART2 -I..\BSP\USART3 -I..\FLib\inc -I..\CORE -I..\SYS\sys -I..\SYS\delay -I..\SYS\usart -IE:\dk\HH-1\HH\Proj\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0 -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__UVISION_VERSION=514 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\obj\usart3.crf ..\BSP\USART3\usart3.c]
                          THUMB

                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;108    //定时器4中断服务程序		    
;;;109    void TIM4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;110    { 	
;;;111    	if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)//是更新中断
000002  2101              MOVS     r1,#1
000004  4808              LDR      r0,|L1.40|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b160              CBZ      r0,|L1.38|
;;;112    	{	 			   
;;;113    		USART3_RX_STA|=1<<15;	//标记接收完成
00000c  4807              LDR      r0,|L1.44|
00000e  8800              LDRH     r0,[r0,#0]  ; USART3_RX_STA
000010  f4404000          ORR      r0,r0,#0x8000
000014  4905              LDR      r1,|L1.44|
000016  8008              STRH     r0,[r1,#0]
;;;114    		TIM_ClearITPendingBit(TIM4, TIM_IT_Update  );  //清除TIMx更新中断标志    
000018  2101              MOVS     r1,#1
00001a  4803              LDR      r0,|L1.40|
00001c  f7fffffe          BL       TIM_ClearITPendingBit
;;;115    		TIM4_Set(0);			//关闭TIM4  
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       TIM4_Set
                  |L1.38|
;;;116    	}	    
;;;117    }
000026  bd10              POP      {r4,pc}
;;;118    //设置TIM4的开关
                          ENDP

                  |L1.40|
                          DCD      0x40000800
                  |L1.44|
                          DCD      USART3_RX_STA

                          AREA ||i.TIM4_Init||, CODE, READONLY, ALIGN=2

                  TIM4_Init PROC
;;;132    //psc：时钟预分频数		 
;;;133    void TIM4_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;134    {	
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;135    	NVIC_InitTypeDef NVIC_InitStructure;
;;;136    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;137    
;;;138    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE); //时钟使能//TIM4时钟使能    
000006  2101              MOVS     r1,#1
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;139    	
;;;140    	//定时器TIM3初始化
;;;141    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	
00000e  f8ad5004          STRH     r5,[sp,#4]
;;;142    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值
000012  f8ad4000          STRH     r4,[sp,#0]
;;;143    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
000016  2000              MOVS     r0,#0
000018  f8ad0006          STRH     r0,[sp,#6]
;;;144    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
00001c  f8ad0002          STRH     r0,[sp,#2]
;;;145    	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx的时间基数单位
000020  4669              MOV      r1,sp
000022  480c              LDR      r0,|L2.84|
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;146     
;;;147    	TIM_ITConfig(TIM4,TIM_IT_Update,ENABLE ); //使能指定的TIM4中断,允许更新中断
000028  2201              MOVS     r2,#1
00002a  4611              MOV      r1,r2
00002c  4809              LDR      r0,|L2.84|
00002e  f7fffffe          BL       TIM_ITConfig
;;;148    
;;;149    	 	  
;;;150    	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
000032  201e              MOVS     r0,#0x1e
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;151    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;//抢占优先级3
000038  2001              MOVS     r0,#1
00003a  f88d000d          STRB     r0,[sp,#0xd]
;;;152    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;		//子优先级3
00003e  2002              MOVS     r0,#2
000040  f88d000e          STRB     r0,[sp,#0xe]
;;;153    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000044  2001              MOVS     r0,#1
000046  f88d000f          STRB     r0,[sp,#0xf]
;;;154    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00004a  a803              ADD      r0,sp,#0xc
00004c  f7fffffe          BL       NVIC_Init
;;;155    	
;;;156    }
000050  bd7f              POP      {r0-r6,pc}
;;;157    #endif		 
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x40000800

                          AREA ||i.TIM4_Set||, CODE, READONLY, ALIGN=2

                  TIM4_Set PROC
;;;119    //sta:0，关闭;1,开启;
;;;120    void TIM4_Set(u8 sta)
000000  b510              PUSH     {r4,lr}
;;;121    {
000002  4604              MOV      r4,r0
;;;122    	if(sta)
000004  b144              CBZ      r4,|L3.24|
;;;123    	{
;;;124           
;;;125    		TIM_SetCounter(TIM4,0);//计数器清空
000006  2100              MOVS     r1,#0
000008  4806              LDR      r0,|L3.36|
00000a  f7fffffe          BL       TIM_SetCounter
;;;126    		TIM_Cmd(TIM4, ENABLE);  //使能TIMx	
00000e  2101              MOVS     r1,#1
000010  4804              LDR      r0,|L3.36|
000012  f7fffffe          BL       TIM_Cmd
000016  e003              B        |L3.32|
                  |L3.24|
;;;127    	}else TIM_Cmd(TIM4, DISABLE);//关闭定时器4	   
000018  2100              MOVS     r1,#0
00001a  4802              LDR      r0,|L3.36|
00001c  f7fffffe          BL       TIM_Cmd
                  |L3.32|
;;;128    }
000020  bd10              POP      {r4,pc}
;;;129    //通用定时器中断初始化
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x40000800

                          AREA ||i.UART_DMA_Config||, CODE, READONLY, ALIGN=1

                  UART_DMA_Config PROC
;;;164    //cmar:存储器地址    
;;;165    void UART_DMA_Config(DMA_Channel_TypeDef*DMA_CHx,u32 cpar,u32 cmar)
000000  b570              PUSH     {r4-r6,lr}
;;;166    {
000002  b08c              SUB      sp,sp,#0x30
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;167    	DMA_InitTypeDef DMA_InitStructure;
;;;168     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);	//使能DMA传输
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;169      DMA_DeInit(DMA_CHx);   //将DMA的通道1寄存器重设为缺省值
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       DMA_DeInit
;;;170    	DMA_InitStructure.DMA_PeripheralBaseAddr = cpar;  //DMA外设ADC基地址
000018  9401              STR      r4,[sp,#4]
;;;171    	DMA_InitStructure.DMA_MemoryBaseAddr = cmar;  //DMA内存基地址
00001a  9502              STR      r5,[sp,#8]
;;;172    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;  //数据传输方向，从内存读取发送到外设
00001c  2010              MOVS     r0,#0x10
00001e  9003              STR      r0,[sp,#0xc]
;;;173    	DMA_InitStructure.DMA_BufferSize = 0;  //DMA通道的DMA缓存的大小
000020  2000              MOVS     r0,#0
000022  9004              STR      r0,[sp,#0x10]
;;;174    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  //外设地址寄存器不变
000024  9005              STR      r0,[sp,#0x14]
;;;175    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  //内存地址寄存器递增
000026  2080              MOVS     r0,#0x80
000028  9006              STR      r0,[sp,#0x18]
;;;176    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  //数据宽度为8位
00002a  2000              MOVS     r0,#0
00002c  9007              STR      r0,[sp,#0x1c]
;;;177    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte; //数据宽度为8位
00002e  9008              STR      r0,[sp,#0x20]
;;;178    	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  //工作在正常缓存模式
000030  9009              STR      r0,[sp,#0x24]
;;;179    	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; //DMA通道 x拥有中优先级 
000032  f44f5080          MOV      r0,#0x1000
000036  900a              STR      r0,[sp,#0x28]
;;;180    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  //DMA通道x没有设置为内存到内存传输
000038  2000              MOVS     r0,#0
00003a  900b              STR      r0,[sp,#0x2c]
;;;181    	DMA_Init(DMA_CHx, &DMA_InitStructure);  //根据DMA_InitStruct中指定的参数初始化DMA的通道USART1_Tx_DMA_Channel所标识的寄存器	
00003c  a901              ADD      r1,sp,#4
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       DMA_Init
;;;182    } 
000044  b00c              ADD      sp,sp,#0x30
000046  bd70              POP      {r4-r6,pc}
;;;183    //开启一次DMA传输
                          ENDP


                          AREA ||i.UART_DMA_Enable||, CODE, READONLY, ALIGN=1

                  UART_DMA_Enable PROC
;;;183    //开启一次DMA传输
;;;184    void UART_DMA_Enable(DMA_Channel_TypeDef*DMA_CHx,u8 len)
000000  b570              PUSH     {r4-r6,lr}
;;;185    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;186    	DMA_Cmd(DMA_CHx, DISABLE );  //关闭 指示的通道        
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       DMA_Cmd
;;;187    	DMA_SetCurrDataCounter(DMA_CHx,len);//DMA通道的DMA缓存的大小	
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       DMA_SetCurrDataCounter
;;;188    	DMA_Cmd(DMA_CHx, ENABLE);           //开启DMA传输
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       DMA_Cmd
;;;189    }	   
00001e  bd70              POP      {r4-r6,pc}
;;;190    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 									 
                          ENDP


                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;22     u16 USART3_RX_STA=0;   	 
;;;23     void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;24     {
;;;25     	u8 res;	    
;;;26     	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)//接收到数据
000002  f2405125          MOV      r1,#0x525
000006  4813              LDR      r0,|L6.84|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b308              CBZ      r0,|L6.82|
;;;27     	{	 
;;;28      
;;;29     	res =USART_ReceiveData(USART3);		
00000e  4811              LDR      r0,|L6.84|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c4              UXTB     r4,r0
;;;30     		if(USART3_RX_STA<USART3_MAX_RECV_LEN)		//还可以接收数据
000016  4810              LDR      r0,|L6.88|
000018  8800              LDRH     r0,[r0,#0]  ; USART3_RX_STA
00001a  f5b06f80          CMP      r0,#0x400
00001e  da12              BGE      |L6.70|
;;;31     		{
;;;32     			TIM_SetCounter(TIM4,0);//计数器清空        				 
000020  2100              MOVS     r1,#0
000022  480e              LDR      r0,|L6.92|
000024  f7fffffe          BL       TIM_SetCounter
;;;33     			if(USART3_RX_STA==0)TIM4_Set(1);	 	//使能定时器4的中断 
000028  480b              LDR      r0,|L6.88|
00002a  8800              LDRH     r0,[r0,#0]  ; USART3_RX_STA
00002c  b910              CBNZ     r0,|L6.52|
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       TIM4_Set
                  |L6.52|
;;;34     			USART3_RX_BUF[USART3_RX_STA++]=res;		//记录接收到的值	 
000034  4808              LDR      r0,|L6.88|
000036  8801              LDRH     r1,[r0,#0]  ; USART3_RX_STA
000038  8800              LDRH     r0,[r0,#0]  ; USART3_RX_STA
00003a  1c40              ADDS     r0,r0,#1
00003c  4a06              LDR      r2,|L6.88|
00003e  8010              STRH     r0,[r2,#0]
000040  4807              LDR      r0,|L6.96|
000042  5444              STRB     r4,[r0,r1]
000044  e005              B        |L6.82|
                  |L6.70|
;;;35     		}else 
;;;36     		{
;;;37     			USART3_RX_STA|=1<<15;					//强制标记接收完成
000046  4804              LDR      r0,|L6.88|
000048  8800              LDRH     r0,[r0,#0]  ; USART3_RX_STA
00004a  f4404000          ORR      r0,r0,#0x8000
00004e  4902              LDR      r1,|L6.88|
000050  8008              STRH     r0,[r1,#0]
                  |L6.82|
;;;38     		} 
;;;39     	}  											 
;;;40     }   
000052  bd10              POP      {r4,pc}
;;;41     //初始化IO 串口2
                          ENDP

                  |L6.84|
                          DCD      0x40004800
                  |L6.88|
                          DCD      USART3_RX_STA
                  |L6.92|
                          DCD      0x40000800
                  |L6.96|
                          DCD      USART3_RX_BUF

                          AREA ||i.USART3_Init||, CODE, READONLY, ALIGN=2

                  USART3_Init PROC
;;;43     //bound:波特率	  
;;;44     void USART3_Init(u32 bound)
000000  b510              PUSH     {r4,lr}
;;;45     {  
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;46     
;;;47     	NVIC_InitTypeDef NVIC_InitStructure;
;;;48     	GPIO_InitTypeDef GPIO_InitStructure;
;;;49     	USART_InitTypeDef USART_InitStructure;
;;;50     
;;;51     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	// GPIOA时钟
000006  2101              MOVS     r1,#1
000008  2008              MOVS     r0,#8
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;52     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE);
00000e  2101              MOVS     r1,#1
000010  0488              LSLS     r0,r1,#18
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;53     
;;;54      	USART_DeInit(USART3);  //复位串口2
000016  482f              LDR      r0,|L7.212|
000018  f7fffffe          BL       USART_DeInit
;;;55     		 //USART2_TX   PA.2
;;;56       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //PA.2
00001c  f44f6080          MOV      r0,#0x400
000020  f8ad0010          STRH     r0,[sp,#0x10]
;;;57       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d0012          STRB     r0,[sp,#0x12]
;;;58       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00002a  2018              MOVS     r0,#0x18
00002c  f88d0013          STRB     r0,[sp,#0x13]
;;;59       GPIO_Init(GPIOB, &GPIO_InitStructure); //初始化PA2
000030  a904              ADD      r1,sp,#0x10
000032  4829              LDR      r0,|L7.216|
000034  f7fffffe          BL       GPIO_Init
;;;60        
;;;61         //USART2_RX	  PA.3
;;;62       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000038  f44f6000          MOV      r0,#0x800
00003c  f8ad0010          STRH     r0,[sp,#0x10]
;;;63       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000040  2004              MOVS     r0,#4
000042  f88d0013          STRB     r0,[sp,#0x13]
;;;64       GPIO_Init(GPIOB, &GPIO_InitStructure);  //初始化PA3
000046  a904              ADD      r1,sp,#0x10
000048  4823              LDR      r0,|L7.216|
00004a  f7fffffe          BL       GPIO_Init
;;;65     	
;;;66     	USART_InitStructure.USART_BaudRate = bound;//一般设置为9600;
00004e  9400              STR      r4,[sp,#0]
;;;67     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000050  2000              MOVS     r0,#0
000052  f8ad0004          STRH     r0,[sp,#4]
;;;68     	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000056  f8ad0006          STRH     r0,[sp,#6]
;;;69     	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
00005a  f8ad0008          STRH     r0,[sp,#8]
;;;70     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00005e  f8ad000c          STRH     r0,[sp,#0xc]
;;;71     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000062  200c              MOVS     r0,#0xc
000064  f8ad000a          STRH     r0,[sp,#0xa]
;;;72       
;;;73     	USART_Init(USART3, &USART_InitStructure); //初始化串口	2
000068  4669              MOV      r1,sp
00006a  481a              LDR      r0,|L7.212|
00006c  f7fffffe          BL       USART_Init
;;;74       
;;;75     	//波特率设置
;;;76      //	USART2->BRR=(pclk1*1000000)/(bound);// 波特率设置	 
;;;77     	//USART2->CR1|=0X200C;  	//1位停止,无校验位.
;;;78     	USART_DMACmd(USART3,USART_DMAReq_Tx,ENABLE);  	//使能串口2的DMA发送
000070  2201              MOVS     r2,#1
000072  2180              MOVS     r1,#0x80
000074  4817              LDR      r0,|L7.212|
000076  f7fffffe          BL       USART_DMACmd
;;;79     	UART_DMA_Config(DMA1_Channel7,(u32)&USART3->DR,(u32)USART3_TX_BUF);//DMA1通道7,外设为串口2,存储器为USART2_TX_BUF 
00007a  4a18              LDR      r2,|L7.220|
00007c  4915              LDR      r1,|L7.212|
00007e  1d09              ADDS     r1,r1,#4
000080  4817              LDR      r0,|L7.224|
000082  f7fffffe          BL       UART_DMA_Config
;;;80     	USART_Cmd(USART3, ENABLE);                    //使能串口 
000086  2101              MOVS     r1,#1
000088  4812              LDR      r0,|L7.212|
00008a  f7fffffe          BL       USART_Cmd
;;;81     	
;;;82     #ifdef USART3_RX_EN		  	//如果使能了接收
;;;83     	//使能接收中断
;;;84       USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);//开启中断   
00008e  2201              MOVS     r2,#1
000090  f2405125          MOV      r1,#0x525
000094  480f              LDR      r0,|L7.212|
000096  f7fffffe          BL       USART_ITConfig
;;;85     	
;;;86     	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00009a  2027              MOVS     r0,#0x27
00009c  f88d0014          STRB     r0,[sp,#0x14]
;;;87     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级3
0000a0  2002              MOVS     r0,#2
0000a2  f88d0015          STRB     r0,[sp,#0x15]
;;;88     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
0000a6  2003              MOVS     r0,#3
0000a8  f88d0016          STRB     r0,[sp,#0x16]
;;;89     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
0000ac  2001              MOVS     r0,#1
0000ae  f88d0017          STRB     r0,[sp,#0x17]
;;;90     	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
0000b2  a805              ADD      r0,sp,#0x14
0000b4  f7fffffe          BL       NVIC_Init
;;;91     	TIM4_Init(999,7199);		//10ms中断
0000b8  f641411f          MOV      r1,#0x1c1f
0000bc  f24030e7          MOV      r0,#0x3e7
0000c0  f7fffffe          BL       TIM4_Init
;;;92     	USART3_RX_STA=0;		//清零
0000c4  2000              MOVS     r0,#0
0000c6  4907              LDR      r1,|L7.228|
0000c8  8008              STRH     r0,[r1,#0]
;;;93     	TIM4_Set(0);			//关闭定时器4
0000ca  f7fffffe          BL       TIM4_Set
;;;94     #endif	 	
;;;95     
;;;96     }
0000ce  b006              ADD      sp,sp,#0x18
0000d0  bd10              POP      {r4,pc}
;;;97     //串口2,printf 函数
                          ENDP

0000d2  0000              DCW      0x0000
                  |L7.212|
                          DCD      0x40004800
                  |L7.216|
                          DCD      0x40010c00
                  |L7.220|
                          DCD      USART3_TX_BUF
                  |L7.224|
                          DCD      0x40020080
                  |L7.228|
                          DCD      USART3_RX_STA

                          AREA ||i.u3_printf||, CODE, READONLY, ALIGN=2

                  u3_printf PROC
;;;98     //确保一次发送数据不超过USART2_MAX_SEND_LEN字节
;;;99     void u3_printf(char* fmt,...)  
000000  b40f              PUSH     {r0-r3}
;;;100    {  
000002  b538              PUSH     {r3-r5,lr}
;;;101    	va_list ap;
;;;102    	va_start(ap,fmt);
000004  a805              ADD      r0,sp,#0x14
000006  9000              STR      r0,[sp,#0]
;;;103    	vsprintf((char*)USART3_TX_BUF,fmt,ap);
000008  480b              LDR      r0,|L8.56|
00000a  9a00              LDR      r2,[sp,#0]
00000c  9904              LDR      r1,[sp,#0x10]
00000e  f7fffffe          BL       __c89vsprintf
;;;104    	va_end(ap);
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
;;;105    	while(DMA_GetCurrDataCounter(DMA1_Channel7)!=0);	//等待通道7传输完成   
000016  bf00              NOP      
                  |L8.24|
000018  4808              LDR      r0,|L8.60|
00001a  f7fffffe          BL       DMA_GetCurrDataCounter
00001e  2800              CMP      r0,#0
000020  d1fa              BNE      |L8.24|
;;;106    	UART_DMA_Enable(DMA1_Channel7,strlen((const char*)USART3_TX_BUF)); 	//通过dma发送出去
000022  4805              LDR      r0,|L8.56|
000024  f7fffffe          BL       strlen
000028  b2c4              UXTB     r4,r0
00002a  4621              MOV      r1,r4
00002c  4803              LDR      r0,|L8.60|
00002e  f7fffffe          BL       UART_DMA_Enable
;;;107    }
000032  bc38              POP      {r3-r5}
000034  f85dfb14          LDR      pc,[sp],#0x14
;;;108    //定时器4中断服务程序		    
                          ENDP

                  |L8.56|
                          DCD      USART3_TX_BUF
                  |L8.60|
                          DCD      0x40020080

                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  USART3_TX_BUF
                          %        1024
                  USART3_RX_BUF
                          %        1024

                          AREA ||.data||, DATA, ALIGN=1

                  USART3_RX_STA
000000  0000              DCW      0x0000

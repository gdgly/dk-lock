; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\driver -I..\BSP -I..\system -I..\tplib -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\app -I..\MQTT -IE:\github\src\Project\RTE -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -W --omf_browse=.\obj\main.crf ..\app\main.c]
                          THUMB

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  main PROC
;;;142    
;;;143    int main(void)
000000  b508              PUSH     {r3,lr}
;;;144    { 
;;;145    	u16 j,i,rxlen;
;;;146    	u16 k = 0x1A;
000002  bf00              NOP      
;;;147    	u8 upload=0; 
000004  bf00              NOP      
;;;148    	u8 *ret;
;;;149    	uint8_t status = 0;
000006  bf00              NOP      
;;;150    //	u8 tt = 0;
;;;151    	static u8 gps_send_flag = 0;
;;;152    //	u8 buf 
;;;153    	u8 end_char[1];
;;;154    	
;;;155    	
;;;156    	end_char[0] = 0x1A;//结束字符
000008  201a              MOVS     r0,#0x1a
00000a  9000              STR      r0,[sp,#0]
;;;157    
;;;158    	
;;;159    	bsp_init();
00000c  f7fffffe          BL       bsp_init
;;;160    	
;;;161                             
;;;162    	USART_OUT(USART1, "uart1 is ok\r\n");
000010  a10e              ADR      r1,|L1.76|
000012  4812              LDR      r0,|L1.92|
000014  f7fffffe          BL       USART_OUT
;;;163    
;;;164    	
;;;165    //	mqtt_keep_alive();
;;;166    //	
;;;167    //	mqtt_qos0();
;;;168    	
;;;169    	while(1)
000018  e017              B        |L1.74|
                  |L1.26|
;;;170    	{
;;;171    	
;;;172    		gprs_init_task();
00001a  f7fffffe          BL       gprs_init_task
;;;173    
;;;174    		ret = gprs_send_at("AT+CIPSEND\r\n", ">", 100, 1000);
00001e  f44f737a          MOV      r3,#0x3e8
000022  2264              MOVS     r2,#0x64
000024  a10e              ADR      r1,|L1.96|
000026  a00f              ADR      r0,|L1.100|
000028  f7fffffe          BL       gprs_send_at
00002c  4604              MOV      r4,r0
;;;175    		if(ret != NULL)
00002e  b154              CBZ      r4,|L1.70|
;;;176    		{
;;;177    			sprintf((char *)send_buff,"aaaaa%s\r\n", end_char);
000030  466a              MOV      r2,sp
000032  a110              ADR      r1,|L1.116|
000034  4812              LDR      r0,|L1.128|
000036  f7fffffe          BL       __2sprintf
;;;178    
;;;179    			gprs_send_at(send_buff, 0, 200, 200);
00003a  23c8              MOVS     r3,#0xc8
00003c  461a              MOV      r2,r3
00003e  2100              MOVS     r1,#0
000040  480f              LDR      r0,|L1.128|
000042  f7fffffe          BL       gprs_send_at
                  |L1.70|
;;;180    //			gprs_send_data(send_buff, 8, 500);
;;;181    
;;;182    //			timer_delay_1ms(1000);
;;;183    		}
;;;184    
;;;185    		usart1_recv_data();
000046  f7fffffe          BL       usart1_recv_data
                  |L1.74|
00004a  e7e6              B        |L1.26|
;;;186    	}
;;;187    	
;;;188    	
;;;189    	
;;;190    	
;;;191    	while(1)
;;;192    	{	 
;;;193    
;;;194    		while(1)
;;;195    		{
;;;196    			gprs_config();
;;;197    			if(gprs_status == 255)
;;;198    			{
;;;199    				MakeFile_MD5_Checksum(PARK_LOCK_Buffer, 16);			
;;;200    				break;
;;;201    			}
;;;202    		}
;;;203    	
;;;204    		
;;;205    		usart1_recv_data();
;;;206    		usart2_recv_data();
;;;207    	
;;;208    		// 电池信息
;;;209    		Bat_V =Get_Adc_Average(ADC_Channel_0,10);
;;;210    		Bat_V=Bat_V*3300/4096;
;;;211    		Bat_V=Bat_V*88/20;
;;;212    		Bat_Pre=(Bat_V-5000)*100/2400;
;;;213    		
;;;214    //		if(Bat_Pre<20&&Bat_Pre>10&&Bat_Pre_Flag==0)
;;;215    		if(timer_is_timeout_1ms(timer_batt, 1000*60*60) == 0)
;;;216    		{	
;;;217    			Bat_Pre_Flag =  1;
;;;218    			memset(send_buff, 0, 100);	
;;;219    			sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",24,2\r\n");
;;;220    
;;;221    			USART_OUT(USART1, "ccc=%s\r\n", send_buff);
;;;222    
;;;223    			ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;224    			if(ret != NULL)
;;;225    			{
;;;226    				memset(expressText, 0 ,512);
;;;227    				memset(cipherText, 0 ,512);
;;;228    				sprintf((char *)expressText, "{%c%s%c:%s}",'"',"battery",'"',"20");
;;;229    				USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;230    				AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;231    				
;;;232    				USART_OUT(USART1, "aesKey=%s\r\n", aesKey);
;;;233    				USART_OUT(USART1, "cipherText=%s\r\n", cipherText);
;;;234    				ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;235    				if(ret != NULL)
;;;236    				{
;;;237    					timer_is_timeout_1ms(timer_heartbeat, 0);
;;;238    				}			
;;;239    			}
;;;240    			else
;;;241    			{
;;;242    			}
;;;243    
;;;244    		}
;;;245    //		//接收锁数据
;;;246    		p1 = strstr((u8*)protocol_buff, "topic: lock/");
;;;247    		p2 = strstr((u8 *)p1,(u8 *)PARK_LOCK_Buffer);
;;;248    		if(strncmp((char *)p1,(char *)"topic: lock/",12)==0)
;;;249    		{
;;;250    			
;;;251    			if(LOCK_ON_READ()==0 || LOCK_OFF_READ()==0)
;;;252    			{
;;;253    			timer_is_timeout_1ms(timer_heartbeat, 0);
;;;254    			USART_OUT(USART1, "lock data\r\n");
;;;255    			memset(receiveText ,0 , 512);
;;;256    			memset(expressText ,0 , 512);
;;;257    			
;;;258    			strcpy((char*)receiveText ,(char *)(p1+33));
;;;259    			USART_OUT(USART1, "receiveText=%s\r\n", receiveText);
;;;260    			AES_Decrypt(expressText, receiveText, aesKey);
;;;261    			if(*expressText==0x31)
;;;262    			{
;;;263    //				if(LOCK_ON_READ() == 0)
;;;264    //				if(lock_on_status_get() == 0)
;;;265    				if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1)
;;;266    				{
;;;267    					timer_is_timeout_1ms(timer_open_lock, 0);
;;;268    					Shaking=1;
;;;269    					Lock_Open=1;
;;;270    					USART_OUT(USART1, "Lock_Open11111\r\n");
;;;271    				}
;;;272    				else
;;;273    				{
;;;274    					Lock_Open=0;
;;;275    				}
;;;276    			}
;;;277    			else if(*expressText==0x32)
;;;278    			{
;;;279    //				if(LOCK_OFF_READ() == 0)
;;;280    //				if(lock_off_status_get() == 0)
;;;281    				if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0)	
;;;282    				{
;;;283    					timer_is_timeout_1ms(timer_close_lock, 0);
;;;284    					Shaking=1;
;;;285    					Lock_Close=1;
;;;286    					USART_OUT(USART1, "Lock_Close11111\r\n");
;;;287    				}
;;;288    				else
;;;289    				{
;;;290    					Lock_Close=0;
;;;291    				}
;;;292    			
;;;293    			}
;;;294    			else if(*expressText == 0x30)
;;;295    			{
;;;296    				lock_stop();	//停止运行;
;;;297    			}
;;;298    			
;;;299    			memset(protocol_buff, 0, 512);					
;;;300    		}
;;;301    	}
;;;302    
;;;303    		//开锁逻辑		
;;;304    		if(Lock_Open == 1)
;;;305    		{
;;;306    
;;;307    			if(timer_is_timeout_1ms(timer_open_lock, 4000) == 0)
;;;308    			{
;;;309    				lock_open_err_flag = 1;
;;;310    				
;;;311    				lock_close();
;;;312    				USART_OUT(USART1, "Lock_Open timer\r\n");
;;;313    			}
;;;314    			USART_OUT(USART1, "Lock_Open\r\n");
;;;315    			if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1)
;;;316    			{
;;;317    				lock_open();	//开锁	
;;;318    				USART_OUT(USART1, "AAA lock_open\r\n");
;;;319    			}
;;;320    //			if(LOCK_OFF_READ()==0) //正常开锁
;;;321    			if(lock_off_status_get() == 0)
;;;322    			{
;;;323    				USART_OUT(USART1, "AAA lock_stop\r\n");
;;;324    				
;;;325    				Lock_Open = 0;
;;;326    				lock_stop();	//停止运行
;;;327    				Shaking = 0;
;;;328    				
;;;329    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;330    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;331    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;332    				if(ret != NULL)
;;;333    				{
;;;334    					memset(expressText, 0 ,512);
;;;335    					memset(cipherText, 0 ,512);
;;;336    					sprintf(expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"0");
;;;337    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;338    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;339    					USART_OUT(USART1, "cipherText=%s\r\n", cipherText);
;;;340    					
;;;341    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;342    					if(ret != NULL)
;;;343    					{
;;;344    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;345    					}
;;;346    				}			
;;;347    			}
;;;348    			
;;;349    			if(LOCK_ON_READ()==0 && LOCK_OFF_READ()==1 && lock_open_err_flag == 1)//开锁超时异常处理
;;;350    			{
;;;351    				lock_open_err_flag = 0;
;;;352    				Lock_Open = 0;
;;;353    				lock_stop();
;;;354    				Shaking = 0;
;;;355    				USART_OUT(USART1, "open lock unusual\r\n");
;;;356    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;357    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;358    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;359    				if(ret != NULL)
;;;360    				{
;;;361    					memset(expressText, 0 ,512);
;;;362    					memset(cipherText, 0 ,512);
;;;363    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"1",'"',"ok",'"',"1");
;;;364    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;365    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;366    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;367    					if(ret != NULL)
;;;368    					{
;;;369    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;370    					}
;;;371    				}
;;;372    				else
;;;373    				{
;;;374    
;;;375    				}	
;;;376    			}
;;;377    		}
;;;378    		//关锁逻辑
;;;379    		if(Lock_Close == 1)
;;;380    		{
;;;381    			if(timer_is_timeout_1ms(timer_close_lock, 4000) == 0)
;;;382    			{
;;;383    				lock_open();
;;;384    				lock_close_err_flag = 1;
;;;385    				USART_OUT(USART1, "Lock_Close timer\r\n");
;;;386    			}
;;;387    			USART_OUT(USART1, "lock close\r\n");
;;;388    			if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0)	//正常关锁
;;;389    			{
;;;390    				lock_close();
;;;391    				USART_OUT(USART1, "BBB lock close\r\n");
;;;392    			}
;;;393    			
;;;394    //			if(LOCK_ON_READ() == 0)	//正常关锁
;;;395    			if(lock_on_status_get() == 0)
;;;396    			{
;;;397    				Lock_Close = 0;
;;;398    				lock_stop();	//停止运行
;;;399    				Shaking = 0;
;;;400    				USART_OUT(USART1, "BBB lock_stop\r\n");
;;;401    				
;;;402    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;403    				USART_OUT(USART1, "PublishLockBackbuf=%s\r\n", send_buff);
;;;404    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;405    				if(ret != NULL)
;;;406    				{
;;;407    					memset(expressText, 0 ,512);
;;;408    					memset(cipherText, 0 ,512);
;;;409    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"0");
;;;410    					USART_OUT(USART1, "expressText=%s\r\n", expressText);
;;;411    					AES_Encrypt((char *)expressText, cipherText, aesKey);
;;;412    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;413    					if(ret != NULL)
;;;414    					{
;;;415    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;416    					}
;;;417    				}
;;;418    			}
;;;419    			
;;;420    			if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==0 && lock_close_err_flag == 1) //关锁超时处理
;;;421    			{
;;;422    				lock_close_err_flag = 0;
;;;423    				Lock_Close = 0;
;;;424    				lock_stop();	//停止运行
;;;425    				Shaking = 0;
;;;426    				USART_OUT(USART1, "close lock unusual\r\n");
;;;427    				sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockback/",(char *)PARK_LOCK_Buffer,",44,2\r\n");
;;;428    				USART_OUT(USART1, "send_buff=%s\r\n", send_buff);
;;;429    				ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;430    				if(ret != NULL)
;;;431    				{
;;;432    					memset(expressText, 0 ,512);
;;;433    					memset(cipherText, 0 ,512);
;;;434    					sprintf((char *)expressText,"{%c%s%c:%s,%c%s%c:%s}",'"',"cmd",'"',"2",'"',"ok",'"',"1");
;;;435    					AES_Encrypt((char *)expressText, (char*)cipherText, (char*)aesKey);
;;;436    				
;;;437    					ret = gprs_send_at(cipherText, "OK", 300, 0);
;;;438    					if(ret != NULL)
;;;439    					{
;;;440    						timer_is_timeout_1ms(timer_heartbeat, 0);
;;;441    					}
;;;442    				}
;;;443    			}		
;;;444    		}
;;;445    		//按键
;;;446    		if(button_get_value() == 0)
;;;447    		{
;;;448    			USART_OUT(USART1, "button_get_value\r\n");
;;;449    			timer_is_timeout_1ms(timer_close_lock, 0);
;;;450    			Lock_Close = 1;
;;;451    			Shaking=1;	
;;;452    		}
;;;453    			
;;;454    		
;;;455    		//报警器
;;;456    		p1 = strstr((char*)protocol_buff, "topic: bell/");
;;;457    		p2 = strstr((char *)p1,(char *)PARK_LOCK_Buffer);
;;;458    		if(strncmp((char *)p1,(char *)"topic: bell/",12)==0 && bell_flag==0)
;;;459    		{
;;;460    			timer_is_timeout_1ms(timer_heartbeat, 0);
;;;461    			USART_OUT(USART1, "bell\r\n");
;;;462    			memset(protocol_buff, 0, 512);	
;;;463    			bell_flag=1;
;;;464      	
;;;465    			BEEP_ON();
;;;466    			timer_delay_1ms(100);
;;;467    			BEEP_OFF();
;;;468    		}
;;;469    				
;;;470    		if(bell_flag == 1)
;;;471    		{
;;;472    			bell_flag = 0;
;;;473    		}
;;;474    		//晃动报警
;;;475    		if(LOCK_ON_READ()==1 && LOCK_OFF_READ()==1 && Shaking==0)
;;;476    		{
;;;477    			USART_OUT(USART1, "Sharking\r\n");
;;;478    			if(timer_is_timeout_1ms(timer_bell_1, 400) == 0)
;;;479    			{
;;;480    				BEEP_ON();
;;;481    			}
;;;482    			if(timer_is_timeout_1ms(timer_bell_2, 800) == 0)
;;;483    			{
;;;484    				BEEP_OFF();
;;;485    			}
;;;486    		}
;;;487    		else
;;;488    		{
;;;489    			BEEP_OFF();
;;;490    		}
;;;491    		
;;;492    		//断线重连
;;;493    		p1 = strstr((char*)protocol_buff, "MQTT CLOSE");
;;;494    		if(p1 !=NULL)
;;;495    		{
;;;496    			memset(protocol_buff, 0, 512);	
;;;497    			gprs_status = 0;
;;;498    			USART_OUT(USART1, "MQTT SERVER CLOSE\r\n");
;;;499    		}
;;;500    		
;;;501    
;;;502    		//心跳
;;;503    		if(timer_is_timeout_1ms(timer_heartbeat, 1000*60*10) == 0)
;;;504    		{
;;;505    			memset(send_buff, 0, 100);
;;;506    			sprintf((char *)send_buff,"%s%s%s","AT+PUBLISH=lockdata/",PARK_LOCK_Buffer,",1,2\r\n");
;;;507    	
;;;508    			USART_OUT(USART1, "heartbeat=%s\r\n", send_buff);
;;;509    			ret = gprs_send_at(send_buff, ">", 300, 2000);
;;;510    			if(ret != NULL)
;;;511    			{
;;;512    				memset(heartbeat_buff, 0, 2);
;;;513    				heartbeat_buff[0] = 0x30;
;;;514    				ret = gprs_send_at(heartbeat_buff, "OK", 300, 0);
;;;515    				if(ret != NULL)
;;;516    				{
;;;517    					
;;;518    				}	
;;;519    			}
;;;520    			else
;;;521    			{
;;;522    				
;;;523    			}
;;;524    		}	
;;;525    		
;;;526    		
;;;527    //		if(timer_is_timeout_1ms(timer_gps_cycle, 1000*60*60*24) == 0)
;;;528    //		{
;;;529    //			gps_flag = 1;
;;;530    //		}
;;;531    		
;;;532    		
;;;533    
;;;534    	}	 
;;;535    }
;;;536     
                          ENDP

                  |L1.76|
00004c  75617274          DCB      "uart1 is ok\r\n",0
000050  31206973
000054  206f6b0d
000058  0a00    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L1.92|
                          DCD      0x40013800
                  |L1.96|
000060  3e00              DCB      ">",0
000062  00                DCB      0
000063  00                DCB      0
                  |L1.100|
000064  41542b43          DCB      "AT+CIPSEND\r\n",0
000068  49505345
00006c  4e440d0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L1.116|
000074  61616161          DCB      "aaaaa%s\r\n",0
000078  6125730d
00007c  0a00    
00007e  00                DCB      0
00007f  00                DCB      0
                  |L1.128|
                          DCD      send_buff

                          AREA ||i.test_encrypt_ecb||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  test_encrypt_ecb PROC
;;;102    
;;;103    static void test_encrypt_ecb(void)
000000  b500              PUSH     {lr}
;;;104    {
000002  b0bf              SUB      sp,sp,#0xfc
;;;105    
;;;106        uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
000004  a022              ADR      r0,|L2.144|
000006  e890000e          LDM      r0,{r1-r3}
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  e9cd233c          STRD     r2,r3,[sp,#0xf0]
000010  913b              STR      r1,[sp,#0xec]
000012  903e              STR      r0,[sp,#0xf8]
;;;107        uint8_t out[] = { 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97 };
000014  a322              ADR      r3,|L2.160|
000016  e9d31200          LDRD     r1,r2,[r3,#0]
00001a  e9d30302          LDRD     r0,r3,[r3,#8]
00001e  e9cd0339          STRD     r0,r3,[sp,#0xe4]
000022  e9cd1237          STRD     r1,r2,[sp,#0xdc]
;;;108    
;;;109    
;;;110        uint8_t in[]  = { 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a };
000026  a322              ADR      r3,|L2.176|
000028  e9d32000          LDRD     r2,r0,[r3,#0]
00002c  e9d31302          LDRD     r1,r3,[r3,#8]
000030  e9cd1335          STRD     r1,r3,[sp,#0xd4]
000034  e9cd2033          STRD     r2,r0,[sp,#0xcc]
;;;111       	struct AES_ctx ctx;
;;;112    	
;;;113    	
;;;114    	sprintf((char *)expressText,"{%c%s%c:%s}",'"',"battery",'"',"20");
000038  a021              ADR      r0,|L2.192|
00003a  2122              MOVS     r1,#0x22
00003c  a321              ADR      r3,|L2.196|
00003e  460a              MOV      r2,r1
000040  e9cd1000          STRD     r1,r0,[sp,#0]
000044  a121              ADR      r1,|L2.204|
000046  4824              LDR      r0,|L2.216|
000048  f7fffffe          BL       __2sprintf
;;;115    //	expressText[0] = 0x31;
;;;116    	USART_OUT(USART1, "expressText66=%s\r\n", expressText);
00004c  4a22              LDR      r2,|L2.216|
00004e  a123              ADR      r1,|L2.220|
000050  4827              LDR      r0,|L2.240|
000052  f7fffffe          BL       USART_OUT
;;;117    	
;;;118    
;;;119    	
;;;120    //	USART_OUT(USART1, "in=%s\r\n", in);
;;;121    //	USART_OUT(USART1, "out=%s\r\n", out);
;;;122    //	AES_init_ctx(&ctx, key);
;;;123    //	AES_ECB_encrypt(&ctx, in);
;;;124    //	USART_OUT(USART1, "in=%s\r\n", in);
;;;125    //	USART_OUT(USART1, "out=%s\r\n", out);
;;;126        AES_init_ctx(&ctx, aesKey);
000056  4927              LDR      r1,|L2.244|
000058  a803              ADD      r0,sp,#0xc
00005a  f7fffffe          BL       AES_init_ctx
;;;127        AES_ECB_encrypt(&ctx, expressText);
00005e  491e              LDR      r1,|L2.216|
000060  a803              ADD      r0,sp,#0xc
000062  f7fffffe          BL       AES_ECB_encrypt
;;;128    
;;;129    	USART_OUT(USART1, expressText);
000066  491c              LDR      r1,|L2.216|
000068  4821              LDR      r0,|L2.240|
00006a  f7fffffe          BL       USART_OUT
;;;130    
;;;131        if (0 == memcmp((char*) out, (char*) in, 16))
00006e  2210              MOVS     r2,#0x10
000070  a933              ADD      r1,sp,#0xcc
000072  a837              ADD      r0,sp,#0xdc
000074  f7fffffe          BL       memcmp
000078  b920              CBNZ     r0,|L2.132|
;;;132        {
;;;133            USART_OUT(USART1, "SUCCESS!\n");
00007a  a11f              ADR      r1,|L2.248|
00007c  481c              LDR      r0,|L2.240|
00007e  f7fffffe          BL       USART_OUT
000082  e003              B        |L2.140|
                  |L2.132|
;;;134        }
;;;135        else
;;;136        {
;;;137            USART_OUT(USART1, "FAILURE!\n");
000084  a11f              ADR      r1,|L2.260|
000086  481a              LDR      r0,|L2.240|
000088  f7fffffe          BL       USART_OUT
                  |L2.140|
;;;138        }
;;;139    }
00008c  b03f              ADD      sp,sp,#0xfc
00008e  bd00              POP      {pc}
;;;140    
                          ENDP

                  |L2.144|
000090  2b7e1516          DCB      "+~",21,22,"(",174,210,166,171,247,21,136,"\t",207,"O<"
000094  28aed2a6
000098  abf71588
00009c  09cf4f3c
                  |L2.160|
0000a0  3ad77bb4          DCB      ":",215,"{",180,"\rz6`",168,158,202,243,"$$f",239,151
0000a4  0d7a3660
0000a8  a89ecaf3
0000ac  2466ef97
                  |L2.176|
0000b0  6bc1bee2          DCB      "k",193,190,226,".@",159,150,233,"=~",17,"s",147,23,"*"
0000b4  2e409f96
0000b8  e93d7e11
0000bc  7393172a
                  |L2.192|
0000c0  323000            DCB      "20",0
0000c3  00                DCB      0
                  |L2.196|
0000c4  62617474          DCB      "battery",0
0000c8  65727900
                  |L2.204|
0000cc  7b256325          DCB      "{%c%s%c:%s}",0
0000d0  7325633a
0000d4  25737d00
                  |L2.216|
                          DCD      expressText
                  |L2.220|
0000dc  65787072          DCB      "expressText66=%s\r\n",0
0000e0  65737354
0000e4  65787436
0000e8  363d2573
0000ec  0d0a00  
0000ef  00                DCB      0
                  |L2.240|
                          DCD      0x40013800
                  |L2.244|
                          DCD      aesKey
                  |L2.248|
0000f8  53554343          DCB      "SUCCESS!\n",0
0000fc  45535321
000100  0a00    
000102  00                DCB      0
000103  00                DCB      0
                  |L2.260|
000104  4641494c          DCB      "FAILURE!\n",0
000108  55524521
00010c  0a00    
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  receiveText
                          %        24
                  expressText
                          %        512
                  cipherText
                          %        512
                  aesKey
                          %        16
                  gpsx
                          %        166
                  longitudedtbuf
                          %        30
                  latitudedtbuf
                          %        30
                  dtbuf
                          %        50
                  lockbuf
                          %        16
                  lockbuff
                          %        16
                  send_buff
                          %        100
                  protocol_buff
                          %        512
                  gps_buff
                          %        512
                  tmp
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  bell_flag
000000  00                DCB      0x00
                  Shaking
000001  00                DCB      0x00
                  Shaking_Alarm_Flag
000002  0000              DCB      0x00,0x00
                  Bat_V
000004  0000              DCB      0x00,0x00
                  Bat_Pre
000006  0000              DCB      0x00,0x00
                  Bat_Pre_Flag
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  ||p1||
                          DCD      0x00000000
                  ||p2||
                          DCD      0x00000000
                  lock_open_err_flag
000014  00                DCB      0x00
                  lock_close_err_flag
000015  00                DCB      0x00
                  Lock_Open
000016  00                DCB      0x00
                  Lock_Open_On
000017  00                DCB      0x00
                  Lock_Open_Off
000018  00                DCB      0x00
                  Lock_Close
000019  00                DCB      0x00
                  Lock_Close_On
00001a  00                DCB      0x00
                  Lock_Close_Off
00001b  00                DCB      0x00
                  lock_open_success_flag
00001c  00                DCB      0x00
                  flag
00001d  04                DCB      0x04
                  second_flag
00001e  00                DCB      0x00
                  LOCK_ON_flag
00001f  01                DCB      0x01
                  LOCK_OFF_flag
000020  01                DCB      0x01
                  gps_flag
000021  00                DCB      0x00
                  gps_err_cnt
000022  00                DCB      0x00
                  heartbeat_buff
000023  00                DCB      0x00
000024  00                DCB      0x00
                  gps_send_flag
000025  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
